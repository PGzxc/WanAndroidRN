"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MotionLinearGradient = void 0;
exports.setLinearGradientComponent = setLinearGradientComponent;

var _tools = require("@legendapp/tools");

var _react = require("@legendapp/tools/react");

var _react2 = _interopRequireWildcard(require("react"));

var _createMotionComponent = require("./createMotionComponent");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

let LinearGradient;

function setLinearGradientComponent(linearGradient) {
  LinearGradient = linearGradient;
}

class GradientHelper extends _react2.Component {
  render() {
    const {
      numColors,
      startX,
      startY,
      endX,
      endY,
      ...rest
    } = this.props; // Combine startX, startY, endX, endY back into start,end

    let start;

    if (startX !== undefined || startY !== undefined) {
      start = {
        x: startX,
        y: startY
      };
    }

    let end;

    if (endX !== undefined || endY !== undefined) {
      end = {
        x: endX,
        y: endY
      };
    } // Combine individual color props back into a colors array


    const colors = [];

    for (let i = 0; i < numColors; i++) {
      colors.push(rest['color' + i]);
      delete rest['color' + i];
    }

    return /*#__PURE__*/_react2.default.createElement(LinearGradient, _extends({
      colors: colors,
      start: start,
      end: end
    }, rest));
  }

}

const AnimatedGradientHelper = (0, _createMotionComponent.createMotionAnimatedComponent)(GradientHelper);

function pointToXY(props, point, name) {
  if (point) {
    props[name + 'X'] = (0, _tools.isArray)(point) ? point[0] : point.x;
    props[name + 'Y'] = (0, _tools.isArray)(point) ? point[1] : point.y;
  }
} // Create MotionLinearGradient with the same API as other Motion components, but it's more complicated because it needs to
// transform to a different set of props into the AnimatedGradientHelper.


const MotionLinearGradient = (0, _react.MemoFnComponent)(function (props) {
  const {
    colors,
    animateProps,
    start,
    end,
    initialProps,
    ...propsOut
  } = props;
  const {
    colors: colorsAnimate,
    start: startAnimate,
    end: endAnimate,
    ...animatePropsOut
  } = animateProps; // Split colors array out into individual props so they can be animated

  colors === null || colors === void 0 ? void 0 : colors.forEach((color, i) => propsOut['color' + i] = color);
  colorsAnimate === null || colorsAnimate === void 0 ? void 0 : colorsAnimate.forEach((color, i) => animatePropsOut['color' + i] = color); // Split start/end objects out into individual props so they can be animated

  pointToXY(propsOut, start, 'start');
  pointToXY(propsOut, end, 'end');
  pointToXY(animatePropsOut, startAnimate, 'start');
  pointToXY(animatePropsOut, endAnimate, 'end');
  let numColors = (colors === null || colors === void 0 ? void 0 : colors.length) || (colorsAnimate === null || colorsAnimate === void 0 ? void 0 : colorsAnimate.length) || 0; // Split initialProps too if it exists

  const initialPropsOut = {};

  if (initialProps) {
    const {
      colors: colorsInitial,
      start: startInitial,
      end: endInitial
    } = animateProps;
    colorsInitial === null || colorsInitial === void 0 ? void 0 : colorsInitial.forEach((color, i) => initialPropsOut['color' + i] = color);
    pointToXY(initialPropsOut, startInitial, 'start');
    pointToXY(initialPropsOut, endInitial, 'end');

    if (colorsInitial) {
      numColors = colorsInitial.length;
    }
  } // @ts-ignore Ignore this because it won't conform to the customized props


  return /*#__PURE__*/_react2.default.createElement(AnimatedGradientHelper, _extends({
    numColors: numColors
  }, propsOut, {
    initialProps: initialPropsOut,
    animateProps: animatePropsOut
  }));
});
exports.MotionLinearGradient = MotionLinearGradient;
//# sourceMappingURL=LinearGradient.js.map