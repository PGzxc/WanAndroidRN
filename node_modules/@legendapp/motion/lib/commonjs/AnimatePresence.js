"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimatePresence = AnimatePresence;

var _tools = require("@legendapp/tools");

var _react = require("@legendapp/tools/react");

var _react2 = _interopRequireWildcard(require("react"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function exitableByKey(children) {
  const map = new Map();

  _react2.Children.forEach(children, child => {
    var _child$props;

    if (child.key && (_child$props = child.props) !== null && _child$props !== void 0 && _child$props.exit && (0, _tools.isString)(child.key)) {
      map.set(child.key, child);
    }
  });

  return map;
}

function AnimatePresence(_ref) {
  let {
    children
  } = _ref;
  const fr = (0, _react.useForceRender)();

  const childArr = _react2.Children.toArray(children);

  const childrenPrevious = (0, _react.usePrevious)(childArr); // Map children and previous children to { key: child }

  const childrenByKey = exitableByKey(childArr);
  const childrenByKeyPrevious = (0, _react.usePrevious)(childrenByKey); // Add newly exited elements to the exiting map

  const exiting = (0, _react2.useRef)(new Map());

  if (childrenByKeyPrevious) {
    childrenByKeyPrevious.forEach((prevChild, key) => {
      if (!childrenByKey.get(key)) {
        exiting.current.set(key, prevChild);
      }
    });
  } // Render exiting elements into the position they were previously


  let childrenToRender = [...childArr];
  exiting.current.forEach((child, key) => {
    if (childrenByKey.get(key)) {
      exiting.current.delete(key);
    } else {
      const index = childrenPrevious.indexOf(child);
      childrenToRender.splice(index, 0, child);
    }
  });
  return /*#__PURE__*/_react2.default.createElement(_react2.default.Fragment, null, childrenToRender.map(child => {
    if (child && child.props.exit) {
      const key = child.key;
      const animKeys = Object.keys(child.props.exit); // Remove the child when all exit animations end

      return key && exiting.current.get(key) && animKeys ? /*#__PURE__*/(0, _react2.cloneElement)(child, {
        animate: child.props.exit,
        onAnimationComplete: animKey => {
          if (exiting.current.has(key)) {
            (0, _tools.arrayRemove)(animKeys, animKey);

            if (animKeys.length === 0) {
              exiting.current.delete(key);
              fr();
            }
          }
        }
      }) : child;
    }

    return child;
  }));
}
//# sourceMappingURL=AnimatePresence.js.map