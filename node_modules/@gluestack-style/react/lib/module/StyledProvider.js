import { get, onChange, set } from './core/colorMode';
import * as React from 'react';
import { Platform, View } from 'react-native';
import { propertyTokenMap } from './propertyTokenMap';
import { platformSpecificSpaceUnits } from './utils';
import { createGlobalStylesWeb } from './createGlobalStylesWeb';
import { createGlobalStyles } from './createGlobalStyles';
let colorModeSet = false;
export const defaultConfig = {
  config: {},
  colorMode: 'light',
  components: {}
};
const defaultContextData = defaultConfig;
const StyledContext = /*#__PURE__*/React.createContext(defaultContextData);
const setCurrentColorMode = inputColorMode => {
  if (inputColorMode) {
    // console.log(get(), '>>>>>>');
    const currentColorMode = get();
    if (currentColorMode !== inputColorMode) {
      set(inputColorMode);
    }
    colorModeSet = true;
  }

  // if (inputColorMode) {
  //   set(inputColorMode === 'dark' ? 'dark' : 'light');
  //   colorModeSet = true;
  // }
};

export const StyledProvider = _ref => {
  let {
    config,
    colorMode,
    children,
    globalStyles,
    _experimentalNestedProvider
  } = _ref;
  const inlineStyleMap = React.useRef({
    initialStyleInjected: false
  });
  inlineStyleMap.current.initialStyleInjected = false;
  const currentConfig = React.useMemo(() => {
    //TODO: Add this later
    return platformSpecificSpaceUnits(config, Platform.OS);
  }, [config]);
  if (Platform.OS === 'web' && globalStyles) {
    const globalStyleInjector = createGlobalStylesWeb(globalStyles);
    globalStyleInjector({
      ...currentConfig,
      propertyTokenMap
    });
  }
  const currentColorMode = React.useMemo(() => {
    return colorMode ?? get() ?? 'light';
  }, [colorMode]);
  const _experimentalNestedProviderRef = React.useRef(null);
  React.useEffect(() => {
    let documentElement = null;
    if (Platform.OS === 'web') {
      if (_experimentalNestedProvider) {
        // write own code for nested colorMode
        documentElement = _experimentalNestedProviderRef.current;
      } else {
        documentElement = document.documentElement;
      }
    }
    // Add gs class name
    if (Platform.OS === 'web') {
      documentElement.classList.add(`gs`);
      documentElement.classList.add(`gs-${currentColorMode}`);
    }

    // GluestackStyleSheet.resolve({ ...config, propertyTokenMap });
    // GluestackStyleSheet.injectInStyle();

    onChange(currentColor => {
      // only for web
      if (Platform.OS === 'web' && !_experimentalNestedProvider) {
        const documentElement = document.documentElement;
        if (Platform.OS === 'web') {
          if (currentColor === 'dark') {
            documentElement.classList.remove(`gs-light`);
          } else {
            documentElement.classList.remove(`gs-dark`);
          }
          documentElement.classList.add(`gs-${currentColor}`);
        }
      }
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  React.useEffect(() => {
    setCurrentColorMode(currentColorMode);
  }, [currentColorMode]);
  React.useLayoutEffect(() => {
    if (Platform.OS === 'web') {
      const toBeInjectedStyles = {};
      if (inlineStyleMap.current.initialStyleInjected) {
        return;
      }
      Object.keys(inlineStyleMap.current).forEach(key => {
        if (key !== 'initialStyleInjected') {
          const styles = inlineStyleMap.current[key];
          if (!toBeInjectedStyles[key]) {
            toBeInjectedStyles[key] = document.createDocumentFragment();
          }
          styles.forEach(style => {
            if (!document.getElementById(style.id)) {
              toBeInjectedStyles[key].appendChild(style);
            }
          });
        }
      });
      Object.keys(toBeInjectedStyles).forEach(key => {
        let wrapperElement = document.querySelector('#' + key);
        if (wrapperElement) {
          wrapperElement.appendChild(toBeInjectedStyles[key]);
        }
        // delete inlineStyleMap.current[key];
      });

      inlineStyleMap.current.initialStyleInjected = true;
    }
  });
  // // Set colormode for the first time
  if (!colorModeSet) {
    setCurrentColorMode(currentColorMode);
  }
  const [animationDriverData, setAnimationDriverData] = React.useState();
  const globalStyleMap = (config === null || config === void 0 ? void 0 : config.globalStyle) && createGlobalStyles(config.globalStyle);
  const contextValue = React.useMemo(() => {
    const styledData = {
      config: currentConfig,
      globalStyle: globalStyleMap,
      animationDriverData,
      setAnimationDriverData,
      inlineStyleMap: inlineStyleMap.current
    };
    if (_experimentalNestedProvider) {
      //@ts-ignore
      styledData._experimentalNestedProvider = _experimentalNestedProvider;
      //@ts-ignore
      styledData.colorMode = colorMode;
    }
    return styledData;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentConfig, globalStyleMap, animationDriverData]);
  const providerComponent = /*#__PURE__*/React.createElement(StyledContext.Provider, {
    value: contextValue
  }, children);
  if (_experimentalNestedProvider) {
    return /*#__PURE__*/React.createElement(View, {
      ref: _experimentalNestedProviderRef
    }, providerComponent);
  } else {
    return /*#__PURE__*/React.createElement(React.Fragment, null, providerComponent);
  }
};
export const useStyled = () => React.useContext(StyledContext);
//# sourceMappingURL=StyledProvider.js.map