import { convertStyledToStyledVerbosed } from './convertSxToSxVerbosed';
import { resolveStringToken } from './utils';
import { stableHash } from './stableHash';
import { propertyTokenMap } from './propertyTokenMap';
import { updateOrderUnResolvedMap } from './updateOrderUnResolvedMap';
import { GluestackStyleSheet } from './style-sheet';
import { resolvePlatformTheme } from './styled';
import { Platform } from 'react-native';

/********************* PLUGINS *****************************/

// var globalPluginStore: never[] = [];
// function setGlobalPluginStore(plugins: any) {
//   if (plugins) {
//     // @ts-ignore
//     globalPluginStore.push(...plugins);
//   }
//   return getGlobalPluginStore();
// }
// function getGlobalPluginStore() {
//   return globalPluginStore;
// }

// export function getInstalledPlugins() {
//   return getGlobalPluginStore();
// }

/********************* CREATE COMPONENTS *****************************/

var globalComponentsStore = {};

// function setGlobalComponentsStore(components: any) {
//   if (components) {
//     // @ts-ignore
//     globalComponentsStore = {
//       ...globalComponentsStore,
//       ...components,
//     };
//   }
//   return getGlobalComponentsStore();
// }

function getGlobalComponentsStore() {
  return globalComponentsStore;
}
export function getInstalledComponents() {
  return getGlobalComponentsStore();
}
export const createComponents = components => {
  return components;
};
export const createConfig = config => {
  if (config.plugins) {
    // config.plugins = setGlobalPluginStore(config.plugins);
  }
  // delete config.plugins;

  if (!config.themes) {
    return config;
  }
  // if (config.components) {
  //   newConfig = resolveComponentThemes(config);
  // }

  if (config.themes) {
    const newConfigWithThemesResolved = resolveThemes(config);
    return newConfigWithThemesResolved;
  }
  return config;
};
const resolveThemes = config => {
  const newConfig = {
    ...config
  };
  Object.keys((newConfig === null || newConfig === void 0 ? void 0 : newConfig.themes) ?? {}).forEach(themeName => {
    let theme = newConfig.themes[themeName];
    Object.keys(theme).forEach(tokenScale => {
      const tokenScaleValue = theme[tokenScale];
      Object.keys(tokenScaleValue).forEach(token => {
        const tokenValue = resolveStringToken(tokenScaleValue[token], newConfig, tokenScale, '');
        tokenScaleValue[token] = tokenValue;
      });
    });
    // const tempCONFIG = JSON.parse(JSON.stringify(newConfig));
    // delete tempCONFIG.themes;
    // deepMerge(tempCONFIG, { tokens: { ...theme } });
    // newConfig.themes[themeName] = tempCONFIG;
  });

  return newConfig;
};
export const resolveComponentTheme = (config, componentTheme) => {
  const configWithPropertyTokenMap = config;
  let resolvedTheme = componentTheme;
  const component = componentTheme;
  if (Object.keys((component === null || component === void 0 ? void 0 : component.BUILD_TIME_PARAMS) ?? {}).length === 0 && component.theme) {
    resolvedTheme = resolveTheme(component.theme, configWithPropertyTokenMap, component === null || component === void 0 ? void 0 : component.componentConfig);
  } else {
    var _component$BUILD_TIME;
    GluestackStyleSheet.update((_component$BUILD_TIME = component.BUILD_TIME_PARAMS) === null || _component$BUILD_TIME === void 0 ? void 0 : _component$BUILD_TIME.orderedResolved);
    resolvedTheme = component;
  }
  return resolvedTheme;
};
export const resolveComponentThemes = (config, components) => {
  let newComponents = {};
  const configWithPropertyTokenMap = {
    ...config,
    propertyTokenMap
  };
  Object.keys(components ?? {}).forEach(componentName => {
    const component = components[componentName];
    if (Object.keys((component === null || component === void 0 ? void 0 : component.BUILD_TIME_PARAMS) ?? {}).length === 0 && component.theme) {
      newComponents[componentName] = resolveTheme(component.theme, configWithPropertyTokenMap, component === null || component === void 0 ? void 0 : component.componentConfig);
    } else {
      var _component$BUILD_TIME2;
      GluestackStyleSheet.update((_component$BUILD_TIME2 = component.BUILD_TIME_PARAMS) === null || _component$BUILD_TIME2 === void 0 ? void 0 : _component$BUILD_TIME2.orderedResolved);
      newComponents[componentName] = component;
    }
  });
  return newComponents;
};
export const resolveTheme = (componentTheme, _config, extendedConfig) => {
  const versboseComponentTheme = convertStyledToStyledVerbosed(componentTheme);
  resolvePlatformTheme(versboseComponentTheme, Platform.OS);
  const componentHash = stableHash({
    ...versboseComponentTheme
  });
  const {
    styledIds,
    verbosedStyleIds
  } = updateOrderUnResolvedMap(versboseComponentTheme, componentHash, 'extended', extendedConfig);
  return {
    styledIds,
    verbosedStyleIds,
    theme: versboseComponentTheme
  };
};
//# sourceMappingURL=createConfig.js.map