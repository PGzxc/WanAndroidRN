import { extractWidthValues } from '../utils';
export function SXResolvedToOrderedSXResolved(sxResolved) {
  var _sxResolved$styledVal;
  let orderedSXResolved = [];
  if (sxResolved !== null && sxResolved !== void 0 && (_sxResolved$styledVal = sxResolved.styledValueResolvedWithMeta) !== null && _sxResolved$styledVal !== void 0 && _sxResolved$styledVal.original) {
    orderedSXResolved = [sxResolved.styledValueResolvedWithMeta];
  }
  if (sxResolved !== null && sxResolved !== void 0 && sxResolved.platform) {
    Object.keys(sxResolved.platform).forEach(key => {
      //@ts-ignore
      const platformSXResolved = sxResolved === null || sxResolved === void 0 ? void 0 : sxResolved.platform[key];
      orderedSXResolved.push(...SXResolvedToOrderedSXResolved(platformSXResolved));
    });
  }
  if (sxResolved !== null && sxResolved !== void 0 && sxResolved.colorMode) {
    Object.keys(sxResolved.colorMode).forEach(key => {
      //@ts-ignore
      const colorModeSXResolved = sxResolved.colorMode[key];
      orderedSXResolved.push(...SXResolvedToOrderedSXResolved(colorModeSXResolved));
    });
  }
  if (sxResolved !== null && sxResolved !== void 0 && sxResolved.queriesResolved) {
    const queriesResolved = {};
    const breakpoints = [];
    // order and push based on config media query order
    sxResolved.queriesResolved.forEach(queryResolved => {
      const queryCondition = queryResolved.resolved.value.styledValueResolvedWithMeta.meta.queryCondition;
      const currentBreakpoint = extractWidthValues(queryCondition);
      if (currentBreakpoint.length === 1) {
        breakpoints.push(currentBreakpoint[0]);
        if (!queriesResolved[currentBreakpoint]) queriesResolved[currentBreakpoint] = [];
        queriesResolved[currentBreakpoint].push(...SXResolvedToOrderedSXResolved(queryResolved.resolved.value));
      } else {
        orderedSXResolved.push(...SXResolvedToOrderedSXResolved(queryResolved.resolved.value));
      }

      // orderedSXResolved.push(
      //   //@ts-ignore
      //   ...SXResolvedToOrderedSXResolved(queryResolved.resolved.value)
      // );
    });

    breakpoints.sort((a, b) => a - b);
    breakpoints.forEach(currentBreakpoint => {
      if (queriesResolved[currentBreakpoint]) orderedSXResolved.push(...queriesResolved[currentBreakpoint]);
    });
  }
  if (sxResolved !== null && sxResolved !== void 0 && sxResolved.state) {
    Object.keys(sxResolved.state).forEach(key => {
      //@ts-ignore
      const stateSXResolved = sxResolved.state[key];
      // stateSXResolved.styledValueResolvedWithMeta.meta.weight =
      //   SX_STYLE_PRECEDENCE.state + (STATE_PRECENDENCE[key] || 0) / 100;
      orderedSXResolved.push(...SXResolvedToOrderedSXResolved(stateSXResolved));
      // orderedSXResolved.push(stateSXResolved.styledValueResolvedWithMeta);
    });
  }

  if (sxResolved !== null && sxResolved !== void 0 && sxResolved.descendants) {
    Object.keys(sxResolved.descendants).forEach(key => {
      //@ts-ignore
      const descendantSXResolved = sxResolved.descendants[key];
      orderedSXResolved.push(...SXResolvedToOrderedSXResolved(descendantSXResolved));
    });
  }
  return orderedSXResolved.sort((a, b) => a.meta.weight - b.meta.weight);
}
//# sourceMappingURL=SXResolvedToOrderedSXResolved.js.map