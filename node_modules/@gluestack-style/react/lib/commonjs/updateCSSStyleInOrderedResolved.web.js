"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.INTERNAL_updateCSSStyleInOrderedResolved = INTERNAL_updateCSSStyleInOrderedResolved;
exports.getCSSIdAndRuleset = getCSSIdAndRuleset;
var _cssify = require("./utils/cssify");
var _stableHash = require("./stableHash");
function getCSSIdAndRuleset(styleValueResolvedWithMeta, objectHash) {
  var _styleValueResolvedWi, _styleValueResolvedWi2;
  let prefixClassName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  const hasState = (_styleValueResolvedWi = styleValueResolvedWithMeta.meta.path) === null || _styleValueResolvedWi === void 0 ? void 0 : _styleValueResolvedWi.includes('state');
  const toBeInjectedStyle = {
    style: styleValueResolvedWithMeta.resolved
  };
  if (styleValueResolvedWithMeta.meta.queryCondition && styleValueResolvedWithMeta.meta.colorMode) {
    toBeInjectedStyle.condition = styleValueResolvedWithMeta.meta.queryCondition;
    toBeInjectedStyle.colorMode = styleValueResolvedWithMeta.meta.colorMode;
  } else if (styleValueResolvedWithMeta.meta.queryCondition) {
    toBeInjectedStyle.condition = styleValueResolvedWithMeta.meta.queryCondition;
  } else if (styleValueResolvedWithMeta.meta.colorMode) {
    toBeInjectedStyle.colorMode = styleValueResolvedWithMeta.meta.colorMode;
  }
  // @ts-ignore
  if (styleValueResolvedWithMeta.meta.themeCondition) {
    // @ts-ignore
    toBeInjectedStyle.themeCondition =
    // @ts-ignore
    styleValueResolvedWithMeta.meta.themeCondition;
  }

  //@ts-ignore
  const cssObject = _cssify.Cssify.create({
    style: toBeInjectedStyle
  },
  // 'helloworld'
  objectHash + '-' + (0, _stableHash.stableHash)({
    path: styleValueResolvedWithMeta === null || styleValueResolvedWithMeta === void 0 || (_styleValueResolvedWi2 = styleValueResolvedWithMeta.meta) === null || _styleValueResolvedWi2 === void 0 ? void 0 : _styleValueResolvedWi2.path,
    data: styleValueResolvedWithMeta.original
  }), prefixClassName, hasState);

  // var hr = stableHash({ hello: 'helloworld' });

  // console.log(
  //   toBeInjectedStyle,
  //   stableHash(toBeInjectedStyle),
  //   'consistant hash @@@@'
  // );
  return cssObject;
}
function INTERNAL_updateCSSStyleInOrderedResolved(orderedSXResolved, objectHash) {
  let keepOriginal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let prefixClassName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  let shouldResolve = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  orderedSXResolved.forEach(styleResolved => {
    if (shouldResolve) {
      const cssData = getCSSIdAndRuleset(styleResolved, objectHash, prefixClassName);
      if (!keepOriginal) {
        delete styleResolved.resolved;
        delete styleResolved.original;
      }
      // console.log(styleResolved, 'CSS DATA');

      styleResolved.meta.cssId = cssData.ids.style;
      styleResolved.meta.cssRuleset = cssData.rules.style;
    } else {
      var _styleResolved$meta;
      styleResolved.meta.cssId = objectHash + '-' + (0, _stableHash.stableHash)({
        path: styleResolved === null || styleResolved === void 0 || (_styleResolved$meta = styleResolved.meta) === null || _styleResolved$meta === void 0 ? void 0 : _styleResolved$meta.path,
        data: styleResolved.original
      });
    }
  });
}
//# sourceMappingURL=updateCSSStyleInOrderedResolved.web.js.map