"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVariantProps = getVariantProps;
exports.resolveBuildTimeSx = resolveBuildTimeSx;
exports.resolvePlatformTheme = resolvePlatformTheme;
exports.styled = styled;
exports.verboseStyled = verboseStyled;
var _react = _interopRequireWildcard(require("react"));
var _utils = require("./utils");
var _convertUtilityToSx = require("./core/convert-utility-to-sx");
var _StyledProvider = require("./StyledProvider");
var _Theme = require("./Theme");
var _propertyTokenMap = require("./propertyTokenMap");
var _reactNative = require("react-native");
var _updateCSSStyleInOrderedResolved = require("./updateCSSStyleInOrderedResolved");
var _generateStylePropsFromCSSIds = require("./generateStylePropsFromCSSIds");
var _colorMode = require("./core/colorMode");
var _orderedResolved = require("./resolver/orderedResolved");
var _styledResolved = require("./resolver/styledResolved");
var _getStyleIds = require("./resolver/getStyleIds");
var _injectComponentAndDescendantStyles = require("./resolver/injectComponentAndDescendantStyles");
var _convertSxToSxVerbosed = require("./convertSxToSxVerbosed");
var _stableHash = require("./stableHash");
var _styleSheet = require("./style-sheet");
var _styledSystem = require("./core/styled-system");
var _updateOrderUnResolvedMap = require("./updateOrderUnResolvedMap");
var _createConfig = require("./createConfig");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); } /* eslint-disable react-hooks/exhaustive-deps */
const styledSystemProps = {
  ..._styledSystem.CSSPropertiesMap
};
function isSubset(subset, set) {
  return subset.every(item => set.includes(item));
}
function flattenObject() {
  let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const flat = {};

  // Recursive function to flatten the object
  function flatten(obj) {
    let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    // Iterate over the object's keys

    if (Array.isArray(obj)) {
      flat[`${path.join('.')}`] = obj;
    } else {
      for (const key of Object.keys(obj)) {
        // If the value is an object, recurse
        if (key === 'ids' && path.length > 0) {
          flat[`${path.join('.')}`] = obj[key];
        } else if (key === 'props') {
          flat[`${path.join('.')}.${key}`] = obj[key];
        } else if (typeof obj[key] === 'object') {
          flatten(obj[key], [...path, key]);
        } else {
          flat[`${path.join('.')}`] = obj[key];
        }
      }
    }
  }
  flatten(obj);
  return flat;
}
function convertUtiltiyToSXFromProps(componentProps, styledSystemProps, componentStyleConfig) {
  // if (componentProps.debug === 'BOX_TEST') {
  //   return {
  //     sx: {},
  //     rest: {},
  //   };
  // }
  const {
    sx: userSX,
    ...componentRestProps
  } = componentProps;
  const resolvedSXVerbosed = (0, _convertSxToSxVerbosed.convertSxToSxVerbosed)(userSX);
  const {
    sxProps: utilityResolvedSX,
    mergedProps: restProps
  } = (0, _convertUtilityToSx.convertUtilityPropsToSX)(styledSystemProps, componentStyleConfig === null || componentStyleConfig === void 0 ? void 0 : componentStyleConfig.descendantStyle, componentRestProps);
  const resolvedSxVerbose = (0, _utils.deepMerge)(utilityResolvedSX, resolvedSXVerbosed);
  return {
    sx: resolvedSxVerbose,
    rest: restProps
  };
}
function getStateStyleCSSFromStyleIdsAndProps(flatternStyleIdObject, currentStateArray) {
  const stateStyleCSSIds = [];
  let props = {};
  Object.keys(flatternStyleIdObject).forEach(styleId => {
    const styleIdKeyArray = styleId.split('.');
    const filteredStyleIdKeyArray = styleIdKeyArray.filter(item => item !== 'colorMode' && item !== 'state' && item !== 'props');
    if (styleId.includes('ids')) {
      // if (type === 'inline' && ) {
      // stateStyleCSSIds.push(...flatternStyleIdObject[styleId]);
      // }
    } else if (styleId.includes('props') && isSubset(filteredStyleIdKeyArray, currentStateArray)) {
      props = (0, _utils.deepMergeObjects)(props, flatternStyleIdObject[styleId]);
    } else {
      if (isSubset(filteredStyleIdKeyArray, currentStateArray)) {
        stateStyleCSSIds.push(...flatternStyleIdObject[styleId]);
      }
    }
  });
  return {
    cssIds: stateStyleCSSIds,
    passingProps: props
  };
}
function resolveBuildTimeSx(userSX, verboseSx, utilityResolvedSX, componentExtendedConfig) {
  const resolvedSXVerbosed = (0, _convertSxToSxVerbosed.convertSxToSxVerbosed)(userSX);
  const resolvedSxVerbose = (0, _utils.deepMerge)(utilityResolvedSX, resolvedSXVerbosed);
  const sx = (0, _utils.deepMerge)(resolvedSxVerbose, verboseSx);
  let STABLEHASH_sx = (0, _stableHash.stableHash)(sx);
  let orderedSXResolved = [];
  if (Object.keys(sx).length > 0) {
    const inlineSxTheme = {
      baseStyle: sx
    };
    resolvePlatformTheme(inlineSxTheme, _reactNative.Platform.OS);
    const sxStyledResolved = (0, _styledResolved.styledToStyledResolved)(
    // @ts-ignore
    inlineSxTheme, [], componentExtendedConfig);
    orderedSXResolved = (0, _orderedResolved.styledResolvedToOrderedSXResolved)(sxStyledResolved);
  }
  return {
    orderedSXResolved,
    STABLEHASH_sx
  };
}
function isValidVariantCondition(condition, variants) {
  for (const key in condition) {
    if (!variants.hasOwnProperty(key) || variants[key] !== condition[key]) {
      return false;
    }
  }
  return true;
}
function getMergedDefaultCSSIdsAndProps(componentStyleIds, incomingVariantProps, theme, properties) {
  var _componentStyleIds$ba;
  // console.setStartTimeStamp('getMergedDefaultCSSIdsAndProps');

  let props = {};
  const baseStyleCSSIds = [];
  const variantStyleCSSIds = [];
  if (componentStyleIds && componentStyleIds !== null && componentStyleIds !== void 0 && componentStyleIds.baseStyle && componentStyleIds !== null && componentStyleIds !== void 0 && (_componentStyleIds$ba = componentStyleIds.baseStyle) !== null && _componentStyleIds$ba !== void 0 && _componentStyleIds$ba.ids) {
    var _componentStyleIds$ba2, _componentStyleIds$ba3;
    baseStyleCSSIds.push(...(componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$ba2 = componentStyleIds.baseStyle) === null || _componentStyleIds$ba2 === void 0 ? void 0 : _componentStyleIds$ba2.ids));
    props = (0, _utils.deepMergeObjects)(props, componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$ba3 = componentStyleIds.baseStyle) === null || _componentStyleIds$ba3 === void 0 ? void 0 : _componentStyleIds$ba3.props);
  }
  let passingVariantProps = {};

  // if (props) {
  passingVariantProps = getVariantProps(props, theme).variantProps;
  // }

  const mergedVariantProps = (0, _utils.shallowMerge)({
    ...passingVariantProps
  }, incomingVariantProps);
  Object.keys(mergedVariantProps).forEach(variant => {
    var _componentStyleIds$va, _componentStyleIds$va2;
    const variantName = mergedVariantProps[variant];
    if (variant && componentStyleIds !== null && componentStyleIds !== void 0 && componentStyleIds.variants && componentStyleIds !== null && componentStyleIds !== void 0 && componentStyleIds.variants[variant] && componentStyleIds !== null && componentStyleIds !== void 0 && (_componentStyleIds$va = componentStyleIds.variants[variant]) !== null && _componentStyleIds$va !== void 0 && _componentStyleIds$va[variantName] && componentStyleIds !== null && componentStyleIds !== void 0 && (_componentStyleIds$va2 = componentStyleIds.variants[variant]) !== null && _componentStyleIds$va2 !== void 0 && (_componentStyleIds$va2 = _componentStyleIds$va2[variantName]) !== null && _componentStyleIds$va2 !== void 0 && _componentStyleIds$va2.ids) {
      var _componentStyleIds$va3, _componentStyleIds$va4;
      variantStyleCSSIds.push(
      //@ts-ignore
      ...(componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$va3 = componentStyleIds.variants[variant]) === null || _componentStyleIds$va3 === void 0 || (_componentStyleIds$va3 = _componentStyleIds$va3[variantName]) === null || _componentStyleIds$va3 === void 0 ? void 0 : _componentStyleIds$va3.ids));

      // if this variant exist in remaining props, remove it from remaining props
      if (properties[variant]) {
        delete properties[variant];
      }
      if (props[variant]) {
        delete props[variant];
      }
      props = (0, _utils.deepMergeObjects)(props, componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$va4 = componentStyleIds.variants[variant]) === null || _componentStyleIds$va4 === void 0 || (_componentStyleIds$va4 = _componentStyleIds$va4[variantName]) === null || _componentStyleIds$va4 === void 0 ? void 0 : _componentStyleIds$va4.props);
    }
  });
  componentStyleIds === null || componentStyleIds === void 0 || componentStyleIds.compoundVariants.forEach(compoundVariant => {
    if (isValidVariantCondition(compoundVariant.condition, mergedVariantProps)) {
      if (compoundVariant.ids) {
        variantStyleCSSIds.push(
        //@ts-ignore
        ...compoundVariant.ids);
      }
      props = (0, _utils.deepMergeObjects)(props, compoundVariant === null || compoundVariant === void 0 ? void 0 : compoundVariant.props);
    }
  });

  // console.setEndTimeStamp('getMergedDefaultCSSIdsAndProps');

  return {
    baseStyleCSSIds: baseStyleCSSIds,
    variantStyleCSSIds: variantStyleCSSIds,
    passingProps: props
  };
}
const getMergeDescendantsStyleCSSIdsAndPropsWithKey = (descendantStyles, variantProps, theme, properties) => {
  // console.setStartTimeStamp('getMergeDescendantsStyleCSSIdsAndPropsWithKey');

  const descendantStyleObj = {};
  if (descendantStyles) {
    var _Object$keys;
    (_Object$keys = Object.keys(descendantStyles)) === null || _Object$keys === void 0 || _Object$keys.forEach(key => {
      const styleObj = descendantStyles[key];
      const {
        baseStyleCSSIds,
        variantStyleCSSIds,
        passingProps: defaultPassingProps
      } = getMergedDefaultCSSIdsAndProps(styleObj, variantProps, theme, properties);
      descendantStyleObj[key] = {
        baseStyleCSSIds: baseStyleCSSIds,
        variantStyleCSSIds: variantStyleCSSIds,
        passingProps: defaultPassingProps
      };
    });
  }
  // console.setEndTimeStamp('getMergeDescendantsStyleCSSIdsAndPropsWithKey');

  return descendantStyleObj;
};
const AncestorStyleContext = /*#__PURE__*/_react.default.createContext({
  sx: {},
  component: {}
});
//

// window['globalStyleMap'] = globalStyleMap;
// const globalOrderedList: any = [];
// setTimeout(() => {
//   const orderedList = globalOrderedList.sort(
//     (a: any, b: any) => a.meta.weight - b.meta.weight
//   );
//   injectInStyle(orderedList);
// });

function getFlattenStyleObjectFromStyleIds(styleIds) {
  var _styleIds$compoundVar;
  const componentBaseStyleFlatternStyleIdObject = flattenObject(styleIds === null || styleIds === void 0 ? void 0 : styleIds.baseStyle);
  const componentVariantFlatternStyleIdObject = {};
  const componentCompoundVariantFlatternStyleIdObject = [];
  const variantKeys = Object.keys((styleIds === null || styleIds === void 0 ? void 0 : styleIds.variants) ?? {});
  variantKeys.forEach(variant => {
    Object.keys(styleIds === null || styleIds === void 0 ? void 0 : styleIds.variants[variant]).forEach(currentVariant => {
      const flatternVariantStyle = flattenObject(styleIds === null || styleIds === void 0 ? void 0 : styleIds.variants[variant][currentVariant]);
      componentVariantFlatternStyleIdObject[`${variant}.${currentVariant}`] = flatternVariantStyle;
    });
  });
  styleIds === null || styleIds === void 0 || (_styleIds$compoundVar = styleIds.compoundVariants) === null || _styleIds$compoundVar === void 0 || _styleIds$compoundVar.forEach(compoundVariant => {
    componentCompoundVariantFlatternStyleIdObject.push(flattenObject(compoundVariant));
  });
  return {
    componentBaseStyleFlatternStyleIdObject,
    componentVariantFlatternStyleIdObject,
    componentCompoundVariantFlatternStyleIdObject
  };
}
function push_unique(arr, ele) {
  if (Array.isArray(arr)) {
    if (Array.isArray(ele)) {
      ele.forEach(element => {
        if (!arr.includes(element)) {
          arr.push(element);
        }
      });
    } else {
      if (!arr.includes(ele)) {
        arr.push(ele);
      }
    }
  }
  return arr;
}
function setStateAndColorModeCssIdsAndProps(colorMode, states, variantProps, theme, componentStyleIds, sxComponentStyleIds, componentBaseStyleFlatternStyleIdObject, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, componentDescendantFlattenStyleObject, sxBaseStyleFlatternStyleObject, sxVariantFlatternStyleObject, sxCompoundVariantFlatternStyleObject, sxDescendantFlattenStyleObject, componentDescendantStyleIds, sxDescendantStyleIds) {
  if (!componentStyleIds) {
    return {
      baseStyleCSSIds: [],
      variantStyleCSSIds: [],
      passingProps: {}
    };
  }
  let stateColorMode = {};
  let currentStateArray = [];
  if (colorMode || states) {
    stateColorMode = {
      ...states,
      [colorMode]: true
    };
    currentStateArray = Object.keys(stateColorMode).filter(key => stateColorMode[key] === true);
  }
  const {
    baseStyleCSSIds: mergedBaseStyleCSSIds,
    variantStyleCSSIds: mergedVariantStyleCSSIds,
    passingProps: stateProps
  } = getMergedStateAndColorModeCSSIdsAndProps(componentStyleIds,
  //@ts-ignore
  componentBaseStyleFlatternStyleIdObject, states, variantProps, colorMode, theme, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, currentStateArray);

  // for sx props
  const {
    baseStyleCSSIds: mergedSXBaseStyleCSSIds,
    variantStyleCSSIds: mergedSXVariantStyleCSSIds,
    passingProps: mergedSxStateProps
  } = getMergedStateAndColorModeCSSIdsAndProps(sxComponentStyleIds.current,
  //@ts-ignore
  sxBaseStyleFlatternStyleObject, states, variantProps, colorMode, theme, sxVariantFlatternStyleObject, sxCompoundVariantFlatternStyleObject, currentStateArray);

  // for descendants
  const mergedDescendantsStyle = {};
  if (componentDescendantStyleIds && Object.keys(componentDescendantStyleIds).length > 0) {
    Object.keys(componentDescendantStyleIds).forEach(key => {
      var _componentDescendantF, _componentDescendantF2, _componentDescendantF3;
      const {
        baseStyleCSSIds: descendantBaseStyleCSSIds,
        variantStyleCSSIds: descendantVariantStyleCSSIds,
        passingProps: mergedPassingProps
      } = getMergedStateAndColorModeCSSIdsAndProps(
      //@ts-ignore
      componentDescendantStyleIds, (_componentDescendantF = componentDescendantFlattenStyleObject[key]) === null || _componentDescendantF === void 0 ? void 0 : _componentDescendantF['componentBaseStyleFlatternStyleIdObject'], states, variantProps, colorMode, theme, (_componentDescendantF2 = componentDescendantFlattenStyleObject[key]) === null || _componentDescendantF2 === void 0 ? void 0 : _componentDescendantF2['componentVariantFlatternStyleIdObject'], (_componentDescendantF3 = componentDescendantFlattenStyleObject[key]) === null || _componentDescendantF3 === void 0 ? void 0 : _componentDescendantF3['componentCompoundVariantFlatternStyleIdObject'], currentStateArray);
      mergedDescendantsStyle[key] = {
        baseStyleCSSIds: descendantBaseStyleCSSIds,
        variantStyleCSSIds: descendantVariantStyleCSSIds,
        passingProps: mergedPassingProps
      };
    });
  }

  // for sx descendants
  const mergedSxDescendantsStyle = {};
  if (sxDescendantStyleIds.current && Object.keys(sxDescendantStyleIds.current).length > 0) {
    Object.keys(sxDescendantStyleIds.current).forEach(key => {
      var _sxDescendantFlattenS, _sxDescendantFlattenS2, _sxDescendantFlattenS3;
      const {
        baseStyleCSSIds: sxDescendantBaseStyleCSSIds,
        variantStyleCSSIds: sxDescendantVariantStyleCSSIds,
        passingProps: mergedPassingProps
      } = getMergedStateAndColorModeCSSIdsAndProps(
      //@ts-ignore
      sxDescendantStyleIds.current, (_sxDescendantFlattenS = sxDescendantFlattenStyleObject[key]) === null || _sxDescendantFlattenS === void 0 ? void 0 : _sxDescendantFlattenS['componentBaseStyleFlatternStyleIdObject'], states, variantProps, colorMode, theme, (_sxDescendantFlattenS2 = sxDescendantFlattenStyleObject[key]) === null || _sxDescendantFlattenS2 === void 0 ? void 0 : _sxDescendantFlattenS2['componentVariantFlatternStyleIdObject'], (_sxDescendantFlattenS3 = sxDescendantFlattenStyleObject[key]) === null || _sxDescendantFlattenS3 === void 0 ? void 0 : _sxDescendantFlattenS3['componentCompoundVariantFlatternStyleIdObject'], currentStateArray);
      mergedSxDescendantsStyle[key] = {
        baseStyleCSSIds: sxDescendantBaseStyleCSSIds,
        variantStyleCSSIds: sxDescendantVariantStyleCSSIds,
        passingProps: mergedPassingProps
      };
    });
  }
  return {
    mergedSXBaseStyleCSSIds,
    mergedSXVariantStyleCSSIds,
    mergedSxStateProps,
    mergedBaseStyleCSSIds,
    mergedVariantStyleCSSIds,
    stateProps,
    mergedSxDescendantsStyle,
    mergedDescendantsStyle
  };
}
function getMergedStateAndColorModeCSSIdsAndProps(componentStyleIds, componentBaseStyleFlatternStyleIdObject, _states, incomingVariantProps, _COLOR_MODE, theme, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, currentStateArray) {
  if (!componentStyleIds) {
    return {
      baseStyleCSSIds: [],
      variantStyleCSSIds: [],
      passingProps: {}
    };
  }
  const stateBaseStyleCSSIds = [];
  const stateVariantStyleCSSIds = [];
  let props = {};
  if (componentBaseStyleFlatternStyleIdObject) {
    const {
      cssIds: stateStleCSSFromStyleIds,
      passingProps: stateStyleProps
    } = getStateStyleCSSFromStyleIdsAndProps(componentBaseStyleFlatternStyleIdObject, currentStateArray);
    push_unique(stateBaseStyleCSSIds, stateStleCSSFromStyleIds);
    // stateBaseStyleCSSIds.push(...stateStleCSSFromStyleIds);
    props = (0, _utils.deepMergeObjects)(props, stateStyleProps);
  }
  let passingVariantProps = getVariantProps(props, theme).variantProps;
  const mergedVariantProps = (0, _utils.shallowMerge)({
    ...passingVariantProps
  }, incomingVariantProps);
  if (componentVariantFlatternStyleIdObject) {
    Object.keys(mergedVariantProps).forEach(variant => {
      const variantObjectPath = `${variant}.${mergedVariantProps[variant]}`;
      if (variant && componentVariantFlatternStyleIdObject !== null && componentVariantFlatternStyleIdObject !== void 0 && componentVariantFlatternStyleIdObject[variantObjectPath]) {
        const {
          cssIds: stateStleCSSFromStyleIds,
          passingProps: stateStyleProps
        } = getStateStyleCSSFromStyleIdsAndProps(componentVariantFlatternStyleIdObject[variantObjectPath], currentStateArray);
        push_unique(stateVariantStyleCSSIds, stateStleCSSFromStyleIds);
        props = (0, _utils.deepMergeObjects)(props, stateStyleProps);
      }
    });
  }
  if (componentCompoundVariantFlatternStyleIdObject.length > 0) {
    var _componentStyleIds$co;
    componentStyleIds === null || componentStyleIds === void 0 || (_componentStyleIds$co = componentStyleIds.compoundVariants) === null || _componentStyleIds$co === void 0 || _componentStyleIds$co.forEach((compoundVariant, index) => {
      if (isValidVariantCondition(compoundVariant.condition, mergedVariantProps)) {
        const {
          cssIds: stateStleCSSFromStyleIds,
          passingProps: stateStyleProps
        } = getStateStyleCSSFromStyleIdsAndProps(componentCompoundVariantFlatternStyleIdObject[index], currentStateArray);
        push_unique(stateVariantStyleCSSIds, stateStleCSSFromStyleIds);
        props = (0, _utils.deepMergeObjects)(props, stateStyleProps);
      }
    });
  }
  return {
    baseStyleCSSIds: stateBaseStyleCSSIds,
    variantStyleCSSIds: stateVariantStyleCSSIds,
    passingProps: props
  };
}
function getAncestorCSSStyleIds(compConfig, context) {
  var _compConfig$ancestorS;
  let ancestorBaseStyleIds = [];
  let ancestorVariantStyleIds = [];
  let ancestorPassingProps = {};
  if (((_compConfig$ancestorS = compConfig.ancestorStyle) === null || _compConfig$ancestorS === void 0 ? void 0 : _compConfig$ancestorS.length) > 0) {
    if (context) {
      compConfig.ancestorStyle.forEach(ancestor => {
        if (context[ancestor]) {
          var _context$ancestor, _context$ancestor2, _context$ancestor3;
          ancestorBaseStyleIds = (_context$ancestor = context[ancestor]) === null || _context$ancestor === void 0 ? void 0 : _context$ancestor.baseStyleCSSIds;
          ancestorVariantStyleIds = (_context$ancestor2 = context[ancestor]) === null || _context$ancestor2 === void 0 ? void 0 : _context$ancestor2.variantStyleCSSIds;
          ancestorPassingProps = (_context$ancestor3 = context[ancestor]) === null || _context$ancestor3 === void 0 ? void 0 : _context$ancestor3.passingProps;
        }
      });
    }
  }
  return {
    baseStyleCSSIds: ancestorBaseStyleIds,
    variantStyleIds: ancestorVariantStyleIds,
    passingProps: ancestorPassingProps
  };
}
function mergeArraysInObjects() {
  const merged = {};
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }
  for (const object of objects) {
    Object.keys(object).forEach(key => {
      const value = object[key];
      if (!merged[key]) {
        merged[key] = {
          baseStyleCSSIds: [],
          variantStyleCSSIds: [],
          passingProps: {}
        };
      }
      merged[key].baseStyleCSSIds.push(...value.baseStyleCSSIds);
      merged[key].variantStyleCSSIds.push(...value.variantStyleCSSIds);
      merged[key].passingProps = (0, _utils.deepMergeObjects)(merged[key].passingProps, value.passingProps);
    });
  }
  return merged;
}
function resolvePlatformTheme(theme, platform) {
  if (typeof theme === 'object') {
    Object.keys(theme).forEach(themeKey => {
      if (themeKey !== 'style' && themeKey !== 'defaultProps') {
        if (theme[themeKey].platform) {
          let temp = {
            ...theme[themeKey]
          };
          theme[themeKey] = (0, _utils.deepMerge)(temp, theme[themeKey].platform[platform]);
          delete theme[themeKey].platform;
          resolvePlatformTheme(theme[themeKey], platform);
        } else if (themeKey === 'queries') {
          theme[themeKey].forEach(query => {
            if (query.value.platform) {
              let temp = {
                ...query.value
              };
              query.value = (0, _utils.deepMerge)(temp, query.value.platform[platform]);
              delete query.value.platform;
            }
            resolvePlatformTheme(query.value, platform);
          });
        } else {
          resolvePlatformTheme(theme[themeKey], platform);
        }
      }
    });
  }
}
function getVariantProps(props, theme) {
  let shouldDeleteVariants = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  const variantTypes = theme !== null && theme !== void 0 && theme.variants ? Object.keys(theme.variants) : [];
  const variantProps = {};
  let restProps = {
    ...props
  };
  if (restProps) {
    variantTypes === null || variantTypes === void 0 || variantTypes.forEach(variant => {
      var _theme$variants$varia;
      if (props.hasOwnProperty(variant) && (_theme$variants$varia = theme.variants[variant]) !== null && _theme$variants$varia !== void 0 && _theme$variants$varia[props[variant]]) {
        var _theme$variants$varia2;
        variantProps[variant] = props[variant];
        restProps = {
          ...(theme === null || theme === void 0 || (_theme$variants$varia2 = theme.variants[variant][props[variant]]) === null || _theme$variants$varia2 === void 0 ? void 0 : _theme$variants$varia2.props),
          ...restProps
        };
        if (shouldDeleteVariants) {
          delete restProps[variant];
        }
      }
    });
  }
  return {
    variantProps,
    restProps
  };
}
function resolveInlineProps(componentStyleConfig, componentExtendedConfig, props, CONFIG) {
  let resolvedInlineProps = {};
  if (componentStyleConfig.resolveProps && Object.keys(componentExtendedConfig).length > 0) {
    componentStyleConfig.resolveProps.forEach(toBeResovledProp => {
      if (props[toBeResovledProp]) {
        let value = props[toBeResovledProp];
        if (CONFIG.propertyResolver && CONFIG.propertyResolver.props && CONFIG.propertyResolver.props[toBeResovledProp]) {
          let transformer = CONFIG.propertyResolver.props[toBeResovledProp];
          let aliasTokenType = CONFIG.propertyTokenMap[toBeResovledProp];
          let token = transformer(value, function (value1) {
            let scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : aliasTokenType;
            return (0, _utils.resolveStringToken)(value1, CONFIG, CONFIG.propertyTokenMap, toBeResovledProp, scale);
          });
          //@ts-ignore
          resolvedInlineProps[toBeResovledProp] = token;
        } else {
          //@ts-ignore
          resolvedInlineProps[toBeResovledProp] = (0, _utils.getResolvedTokenValueFromConfig)(componentExtendedConfig, props, toBeResovledProp, props[toBeResovledProp]);
        }
        delete props[toBeResovledProp];
      }
    });
  }
  return resolvedInlineProps;
}
const getStyleIdsFromMap = (CONFIG, ExtendedConfig, styleIds) => {
  var _componentExtendedCon;
  let componentExtendedConfig = CONFIG;
  if (ExtendedConfig) {
    componentExtendedConfig = (0, _utils.deepMerge)(CONFIG, ExtendedConfig);
  }
  Object.assign(styledSystemProps, (_componentExtendedCon = componentExtendedConfig) === null || _componentExtendedCon === void 0 ? void 0 : _componentExtendedCon.aliases);
  const componentStyleIds = styleIds.component;
  const componentDescendantStyleIds = styleIds.descendant;
  const {
    componentBaseStyleFlatternStyleIdObject,
    componentVariantFlatternStyleIdObject,
    componentCompoundVariantFlatternStyleIdObject
  } = getFlattenStyleObjectFromStyleIds(componentStyleIds);
  const descendantFlattenStyles = {};
  if (componentDescendantStyleIds) {
    Object.keys(componentDescendantStyleIds).forEach(currentDescendant => {
      descendantFlattenStyles[currentDescendant] = getFlattenStyleObjectFromStyleIds(componentDescendantStyleIds[currentDescendant]);
    });
  }
  const componentStyleObject = {
    componentStyleIds,
    componentDescendantStyleIds,
    componentExtendedConfig,
    componentBaseStyleFlatternStyleIdObject,
    componentVariantFlatternStyleIdObject,
    componentCompoundVariantFlatternStyleIdObject,
    descendantFlattenStyles
  };
  return componentStyleObject;
};
function verboseStyled(Component, theme) {
  var _componentStyleConfig, _Component2;
  let componentStyleConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let ExtendedConfig = arguments.length > 3 ? arguments[3] : undefined;
  let BUILD_TIME_PARAMS = arguments.length > 4 ? arguments[4] : undefined;
  let nonVerbosedTheme = arguments.length > 5 ? arguments[5] : undefined;
  // const componentName = componentStyleConfig?.componentName;
  const componentHash = (0, _stableHash.stableHash)({
    ...theme,
    ...componentStyleConfig,
    ...ExtendedConfig
  });
  let declarationType = 'boot';
  if (Component.displayName === '__AsForwarder__') {
    declarationType = 'forwarded';
  }
  resolvePlatformTheme(theme, _reactNative.Platform.OS);

  // const DEBUG_TAG = componentStyleConfig?.DEBUG;
  // const DEBUG =
  //   process.env.NODE_ENV === 'development' && DEBUG_TAG ? false : false;

  //@ts-ignore
  let styleHashCreated = false;
  let pluginData;
  let orderedResolved;
  let componentStyleIds = {};
  let componentDescendantStyleIds = {}; // StyleIds = {};
  let componentExtendedConfig = {};
  let componentBaseStyleFlatternStyleIdObject = {};
  let componentVariantFlatternStyleIdObject = {};
  let componentCompoundVariantFlatternStyleIdObject = [];
  let componentDescendantFlattenStyles = {};
  let styleIds = {};
  let orderedCSSIds = [];
  // const orderedUnResolvedTheme = updateOrderUnResolvedMap(
  //   theme,
  //   componentHash,
  //   declarationType,
  //   ExtendedConfig
  // );

  // styleIds = getStyleIds(orderedUnResolvedTheme, componentStyleConfig);

  if (BUILD_TIME_PARAMS !== null && BUILD_TIME_PARAMS !== void 0 && BUILD_TIME_PARAMS.orderedResolved) {
    orderedResolved = BUILD_TIME_PARAMS === null || BUILD_TIME_PARAMS === void 0 ? void 0 : BUILD_TIME_PARAMS.orderedResolved;
    orderedCSSIds = BUILD_TIME_PARAMS === null || BUILD_TIME_PARAMS === void 0 ? void 0 : BUILD_TIME_PARAMS.styledIds;
    _styleSheet.GluestackStyleSheet.update(orderedResolved);
  } else {
    const {
      styledIds: g,
      verbosedStyleIds
    } = (0, _updateOrderUnResolvedMap.updateOrderUnResolvedMap)(theme, componentHash, declarationType, componentStyleConfig);
    orderedCSSIds = g;
    styleIds = verbosedStyleIds;
  }
  if (BUILD_TIME_PARAMS !== null && BUILD_TIME_PARAMS !== void 0 && BUILD_TIME_PARAMS.verbosedStyleIds) {
    styleIds = BUILD_TIME_PARAMS === null || BUILD_TIME_PARAMS === void 0 ? void 0 : BUILD_TIME_PARAMS.verbosedStyleIds;
  }
  function injectSx(sx) {
    var _sxStyledResolved$bas;
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'inline';
    let inlineStyleMap = arguments.length > 2 ? arguments[2] : undefined;
    const inlineSxTheme = {
      baseStyle: sx
    };
    resolvePlatformTheme(inlineSxTheme, _reactNative.Platform.OS);
    const sxStyledResolved = (0, _styledResolved.styledToStyledResolved)(
    // @ts-ignore
    inlineSxTheme, [], componentExtendedConfig);
    let componentTheme =
    // @ts-ignore
    sxStyledResolved.baseStyle.styledValueResolvedWithMeta;

    // sxStyledResolved.baseStyle.styledValueResolvedWithMeta =
    (0, _utils.addThemeConditionInMeta)(componentTheme, CONFIG);
    const colorModeComponentThemes = (_sxStyledResolved$bas = sxStyledResolved.baseStyle) === null || _sxStyledResolved$bas === void 0 ? void 0 : _sxStyledResolved$bas.colorMode;
    if (colorModeComponentThemes) {
      Object.keys(colorModeComponentThemes).forEach(colorModeComponentTheme => {
        var _colorModeComponentTh;
        if (!((_colorModeComponentTh = colorModeComponentThemes[colorModeComponentTheme].styledValueResolvedWithMeta) !== null && _colorModeComponentTh !== void 0 && _colorModeComponentTh.meta.themeCondition)) {
          colorModeComponentThemes[colorModeComponentTheme].styledValueResolvedWithMeta.meta.themeCondition = {};
        }
        let componentTheme = colorModeComponentThemes[colorModeComponentTheme].styledValueResolvedWithMeta;
        (0, _utils.addThemeConditionInMeta)(componentTheme, CONFIG);
      });
    }
    const sxHash = (0, _stableHash.stableHash)(sx);
    const orderedSXResolved = (0, _orderedResolved.styledResolvedToOrderedSXResolved)(sxStyledResolved);
    (0, _updateCSSStyleInOrderedResolved.INTERNAL_updateCSSStyleInOrderedResolved)(orderedSXResolved, sxHash, false, 'gs');
    (0, _injectComponentAndDescendantStyles.injectComponentAndDescendantStyles)(orderedSXResolved, sxHash, type, _styleSheet.GluestackStyleSheet, _reactNative.Platform.OS, inlineStyleMap);
    return orderedSXResolved;
  }

  // END BASE COLOR MODE RESOLUTION

  let CONFIG = {};
  let isInjected = false;
  let plugins = [];
  const containsDescendant = (componentStyleConfig === null || componentStyleConfig === void 0 ? void 0 : componentStyleConfig.descendantStyle) && (componentStyleConfig === null || componentStyleConfig === void 0 || (_componentStyleConfig = componentStyleConfig.descendantStyle) === null || _componentStyleConfig === void 0 ? void 0 : _componentStyleConfig.length) > 0;
  const StyledComponent = (_ref, ref) => {
    var _theme$baseStyle;
    let {
      children,
      //@ts-ignore
      orderedResolved: BUILD_TIME_ORDERED_RESOLVED = [],
      //@ts-ignore
      verbosedStyleIds: BUILD_TIME_VERBOSED_STYLE_IDS = {},
      //@ts-ignore
      states,
      // styledIds: BUILD_TIME_STYLE_IDS = [],
      // sxHash: BUILD_TIME_sxHash = '',
      ...componentProps
    } = _ref;
    const isClient = _react.default.useRef(false);

    //@ts-ignore
    let themeDefaultProps = {
      ...((_theme$baseStyle = theme.baseStyle) === null || _theme$baseStyle === void 0 ? void 0 : _theme$baseStyle.props)
    };
    const sxComponentStyleIds = (0, _react.useRef)({});
    const sxDescendantStyleIds = (0, _react.useRef)({});
    const sxComponentPassingProps = (0, _react.useRef)({});
    const applySxBaseStyleCSSIds = (0, _react.useRef)([]);
    const applySxVariantStyleCSSIds = (0, _react.useRef)([]);
    const applySxDescendantStyleCSSIdsAndPropsWithKey = (0, _react.useRef)({});
    const styledContext = (0, _StyledProvider.useStyled)();
    const {
      theme: activeTheme
    } = (0, _Theme.useTheme)();
    const ancestorStyleContext = (0, _react.useContext)(AncestorStyleContext);
    let incomingComponentProps = {};
    let applyComponentInlineProps = {};
    const sxBaseStyleFlatternStyleObject = _react.default.useRef({});
    const sxVariantFlatternStyleObject = _react.default.useRef({});
    const sxCompoundVariantFlatternStyleObject = _react.default.useRef({});
    const sxDescendantFlattenStyles = _react.default.useRef({});
    const COLOR_MODE = styledContext._experimentalNestedProvider ? styledContext.colorMode : (0, _colorMode.get)();
    if (!styleHashCreated) {
      var _CONFIG, _CONFIG2;
      CONFIG = {
        ...styledContext.config,
        propertyTokenMap: _propertyTokenMap.propertyTokenMap
      };
      // for extended components

      const EXTENDED_THEME = componentStyleConfig.componentName && ((_CONFIG = CONFIG) === null || _CONFIG === void 0 || (_CONFIG = _CONFIG.components) === null || _CONFIG === void 0 ? void 0 : _CONFIG[componentStyleConfig.componentName]);

      // middleware logic

      // Injecting style
      if (EXTENDED_THEME) {
        var _theme;
        // RUN Middlewares

        nonVerbosedTheme = (0, _utils.deepMerge)(nonVerbosedTheme, EXTENDED_THEME.theme);
        const resolvedComponentExtendedTheme = (0, _createConfig.resolveComponentTheme)(CONFIG, EXTENDED_THEME);

        // const resolvedComponentExtendedTheme = EXTENDED_THEME;

        theme = (0, _utils.deepMerge)(theme, resolvedComponentExtendedTheme.theme);
        // @ts-ignore
        Object.assign(themeDefaultProps, (_theme = theme) === null || _theme === void 0 || (_theme = _theme.baseStyle) === null || _theme === void 0 ? void 0 : _theme.props);
        if (Object.keys((EXTENDED_THEME === null || EXTENDED_THEME === void 0 ? void 0 : EXTENDED_THEME.BUILD_TIME_PARAMS) ?? {}).length > 0) {
          const EXTENDED_THEME_BUILD_TIME_PARAMS = EXTENDED_THEME === null || EXTENDED_THEME === void 0 ? void 0 : EXTENDED_THEME.BUILD_TIME_PARAMS;
          (0, _utils.deepMergeArray)(styleIds, EXTENDED_THEME_BUILD_TIME_PARAMS === null || EXTENDED_THEME_BUILD_TIME_PARAMS === void 0 ? void 0 : EXTENDED_THEME_BUILD_TIME_PARAMS.verbosedStyleIds);
          _styleSheet.GluestackStyleSheet.inject(EXTENDED_THEME_BUILD_TIME_PARAMS === null || EXTENDED_THEME_BUILD_TIME_PARAMS === void 0 ? void 0 : EXTENDED_THEME_BUILD_TIME_PARAMS.toBeInjected, styledContext.inlineStyleMap);
        } else {
          // Merge of Extended Config Style ID's with Component Style ID's
          (0, _utils.deepMergeArray)(styleIds, resolvedComponentExtendedTheme === null || resolvedComponentExtendedTheme === void 0 ? void 0 : resolvedComponentExtendedTheme.verbosedStyleIds);
          const extendedStylesToBeInjected = _styleSheet.GluestackStyleSheet.resolve(resolvedComponentExtendedTheme === null || resolvedComponentExtendedTheme === void 0 ? void 0 : resolvedComponentExtendedTheme.styledIds, CONFIG, componentExtendedConfig);
          _styleSheet.GluestackStyleSheet.inject(extendedStylesToBeInjected, styledContext.inlineStyleMap);
        }
      }
      if (CONFIG.plugins) {
        plugins.push(...CONFIG.plugins);
      }
      if (ExtendedConfig !== null && ExtendedConfig !== void 0 && ExtendedConfig.plugins) {
        plugins.push(...(ExtendedConfig === null || ExtendedConfig === void 0 ? void 0 : ExtendedConfig.plugins));
      }
      if (plugins) {
        for (const pluginName in plugins) {
          var _plugins$pluginName;
          // @ts-ignore
          [nonVerbosedTheme,,, Component] = (_plugins$pluginName = plugins[pluginName]) === null || _plugins$pluginName === void 0 ? void 0 : _plugins$pluginName.inputMiddleWare(nonVerbosedTheme, true, true, Component);
        }
        nonVerbosedTheme = (0, _convertSxToSxVerbosed.convertStyledToStyledVerbosed)(nonVerbosedTheme);
      }

      // for extended components end

      //@ts-ignore
      const globalStyle = styledContext.globalStyle;
      if (globalStyle) {
        const {
          globalStyleIds,
          globalVerbosedStyleIds,
          globalTheme
        } = globalStyle;
        theme.variants = (0, _utils.deepMerge)(theme.variants, globalTheme.variants);
        // Merge of Extended Config Style ID's with Component Style ID's
        (0, _utils.deepMergeArray)(styleIds, globalVerbosedStyleIds);
        // Injecting Extended StyleSheet from Config
        orderedCSSIds = [...orderedCSSIds, ...globalStyleIds];
      }
      if (!BUILD_TIME_PARAMS || !(BUILD_TIME_PARAMS !== null && BUILD_TIME_PARAMS !== void 0 && BUILD_TIME_PARAMS.orderedResolved) || (BUILD_TIME_PARAMS === null || BUILD_TIME_PARAMS === void 0 ? void 0 : BUILD_TIME_PARAMS.orderedResolved.length) === 0) {
        const toBeInjected = _styleSheet.GluestackStyleSheet.resolve(orderedCSSIds, CONFIG, componentExtendedConfig);
        if (_reactNative.Platform.OS === 'web') {
          _styleSheet.GluestackStyleSheet.inject(toBeInjected, styledContext.inlineStyleMap);
        }
      } else {
        if (_reactNative.Platform.OS === 'web') {
          //@ts-ignore
          _styleSheet.GluestackStyleSheet.inject(BUILD_TIME_PARAMS.toBeInjected, styledContext.inlineStyleMap);
        }
      }
      Object.assign(styledSystemProps, (_CONFIG2 = CONFIG) === null || _CONFIG2 === void 0 ? void 0 : _CONFIG2.aliases);
      const {
        componentStyleIds: c,
        componentDescendantStyleIds: d,
        componentExtendedConfig: f,
        componentBaseStyleFlatternStyleIdObject: g,
        componentVariantFlatternStyleIdObject: h,
        componentCompoundVariantFlatternStyleIdObject: i,
        descendantFlattenStyles
      } = getStyleIdsFromMap(CONFIG, ExtendedConfig, styleIds);
      componentStyleIds = c;
      componentDescendantStyleIds = d;
      componentExtendedConfig = f;
      componentBaseStyleFlatternStyleIdObject = g;
      componentVariantFlatternStyleIdObject = h;
      componentCompoundVariantFlatternStyleIdObject = i;
      componentDescendantFlattenStyles = descendantFlattenStyles;
      styleHashCreated = true;

      /* Boot time */
    }

    const {
      passingProps: applyAncestorPassingProps,
      baseStyleCSSIds: applyAncestorBaseStyleCSSIds,
      variantStyleIds: applyAncestorVariantStyleCSSIds
    } = getAncestorCSSStyleIds(componentStyleConfig, ancestorStyleContext.component);
    const {
      passingProps: applySxAncestorPassingProps,
      baseStyleCSSIds: applySxAncestorBaseStyleCSSIds,
      variantStyleIds: applySxAncestorVariantStyleCSSIds
    } = getAncestorCSSStyleIds(componentStyleConfig, ancestorStyleContext.sx);
    Object.assign(incomingComponentProps, applyAncestorPassingProps);
    Object.assign(incomingComponentProps, applySxAncestorPassingProps);
    Object.assign(incomingComponentProps, componentProps);
    const {
      variantProps: defaultVariantProps,
      restProps: defaultComponentPropsWithoutVariants
    } = getVariantProps(themeDefaultProps, theme);
    const {
      variantProps: inlineVariantProps,
      restProps: inlineComponentPropsWithoutVariants
    } = getVariantProps(incomingComponentProps, theme);
    const variantProps = Object.assign(defaultVariantProps, inlineVariantProps);
    const {
      baseStyleCSSIds: applyBaseStyleCSSIds,
      variantStyleCSSIds: applyVariantStyleCSSIds,
      passingProps: applyComponentPassingProps
    } = getMergedDefaultCSSIdsAndProps(
    //@ts-ignore
    componentStyleIds, variantProps, theme, incomingComponentProps);
    let mergedBaseStyleCSSIds = [];
    let mergedVariantStyleCSSIds = [];
    let stateProps = [];
    let mergedSXBaseStyleCSSIds = [];
    let mergedSXVariantStyleCSSIds = [];
    let mergedSxStateProps = [];
    let mergedSxDescendantsStyle = {};
    let mergedDescendantsStyle = {};
    let orderedComponentSXResolved = [];
    let orderedPassingSXResolved = [];
    const sxStyleIds = _react.default.useRef(BUILD_TIME_VERBOSED_STYLE_IDS);
    if (BUILD_TIME_ORDERED_RESOLVED.length > 0 && !isClient.current) {
      var _sxStyleIds$current;
      if (!isInjected) {
        const toBeInjected = _styleSheet.GluestackStyleSheet.update(BUILD_TIME_ORDERED_RESOLVED);
        if (_reactNative.Platform.OS === 'web') {
          _styleSheet.GluestackStyleSheet.inject(toBeInjected, styledContext.inlineStyleMap);
        }
        isInjected = true;
      }
      sxStyleIds.current = BUILD_TIME_VERBOSED_STYLE_IDS;
      if (!sxStyleIds.current.component) {
        sxStyleIds.current.component = {};
      }
      sxStyleIds.current.component.variants = componentStyleIds.variants;
      //@ts-ignore
      sxStyleIds.current.component.compoundVariants = componentStyleIds.compoundVariants;
      // console.setStartTimeStamp('setColorModeBaseStyleIds');
      sxComponentStyleIds.current = (_sxStyleIds$current = sxStyleIds.current) === null || _sxStyleIds$current === void 0 ? void 0 : _sxStyleIds$current.component;
      sxDescendantStyleIds.current = sxStyleIds.current.descendant;
      // 315ms
      // SX component style
      //@ts-ignore
      const {
        baseStyleCSSIds: sxBaseStyleCSSIds,
        variantStyleCSSIds: sxVariantStyleCSSIds,
        passingProps: sxPassingProps
      } = getMergedDefaultCSSIdsAndProps(
      //@ts-ignore
      sxComponentStyleIds.current, variantProps, theme, incomingComponentProps);
      //@ts-ignore
      // applySxStyleCSSIds.current = sxStyleCSSIds;
      //@ts-ignore
      applySxBaseStyleCSSIds.current = sxBaseStyleCSSIds;
      //@ts-ignore
      applySxVariantStyleCSSIds.current = sxVariantStyleCSSIds;
      sxComponentPassingProps.current = sxPassingProps;
      const {
        componentBaseStyleFlatternStyleIdObject: a,
        componentVariantFlatternStyleIdObject: b,
        componentCompoundVariantFlatternStyleIdObject: c
      } = getFlattenStyleObjectFromStyleIds(sxComponentStyleIds.current);
      if (sxDescendantStyleIds.current && containsDescendant) {
        Object.keys(sxDescendantStyleIds.current).forEach(currentDescendant => {
          sxDescendantFlattenStyles.current[currentDescendant] = getFlattenStyleObjectFromStyleIds(sxDescendantStyleIds.current[currentDescendant]);
        });
      }
      sxBaseStyleFlatternStyleObject.current = a;
      sxVariantFlatternStyleObject.current = b;
      sxCompoundVariantFlatternStyleObject.current = c;
    }
    if (!isClient.current) {
      const {
        mergedBaseStyleCSSIds: a,
        mergedVariantStyleCSSIds: b,
        stateProps: c,
        mergedSXBaseStyleCSSIds: d,
        mergedSXVariantStyleCSSIds: e,
        mergedSxStateProps: f,
        mergedSxDescendantsStyle: g,
        mergedDescendantsStyle: h
      } = setStateAndColorModeCssIdsAndProps(COLOR_MODE, states, variantProps, theme, componentStyleIds, sxComponentStyleIds, componentBaseStyleFlatternStyleIdObject, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, componentDescendantFlattenStyles, sxBaseStyleFlatternStyleObject.current, sxVariantFlatternStyleObject.current, sxCompoundVariantFlatternStyleObject.current, sxDescendantFlattenStyles.current, componentDescendantStyleIds, sxDescendantStyleIds);
      mergedBaseStyleCSSIds = a;
      mergedVariantStyleCSSIds = b;
      stateProps = c;
      mergedSXBaseStyleCSSIds = d;
      mergedSXVariantStyleCSSIds = e;
      mergedSxStateProps = f;
      mergedSxDescendantsStyle = g;
      mergedDescendantsStyle = h;
    }
    const applySxStateBaseStyleCSSIds = (0, _react.useRef)(mergedSXBaseStyleCSSIds);
    const applySxStatePassingProps = (0, _react.useRef)(mergedSxDescendantsStyle);
    const applySxDescendantStateStyleCSSIdsAndPropsWithKey = (0, _react.useRef)(mergedSxStateProps);
    const [componentStatePassingProps, setComponentStatePassingProps] = (0, _react.useState)(stateProps);
    // const [sxStatePassingProps, setSxStatePassingProps] =
    //   useState(mergedSxStateProps);

    const [applyComponentStateVariantStyleIds, setApplyComponentStateVariantStyleIds] = (0, _react.useState)(mergedVariantStyleCSSIds);

    // const [applySxStateBaseStyleCSSIds, setApplyStateSxBaseStyleCSSIds] =
    //   useState(mergedSXBaseStyleCSSIds);

    // const [applySxStateVariantStyleCSSIds, setApplyStateSxVariantStyleCSSIds] =
    //   useState(mergedSXVariantStyleCSSIds);
    const applySxStateVariantStyleCSSIds = (0, _react.useRef)(mergedSXVariantStyleCSSIds);
    const [applyDescendantStateStyleCSSIdsAndPropsWithKey, setApplyDescendantStateStyleCSSIdsAndPropsWithKey] = (0, _react.useState)(mergedDescendantsStyle);
    // const [
    //   applySxDescendantStateStyleCSSIdsAndPropsWithKey,
    //   setApplySxDescendantStateStyleCSSIdsAndPropsWithKey,
    // ] = useState(mergedSxDescendantsStyle);

    // passingProps is specific to current component

    // let applyComponentInlineProps: any = componentPropsWithoutVariants;

    // const STABLEHASH_states = stableHash(states);
    // 520ms

    // Inline prop based style resolution TODO: Diagram insertion
    const defaultResolvedInlineProps = resolveInlineProps(componentStyleConfig, componentExtendedConfig, defaultComponentPropsWithoutVariants, CONFIG);
    const inlineResolvedInlineProps = resolveInlineProps(componentStyleConfig, componentExtendedConfig, inlineComponentPropsWithoutVariants, CONFIG);
    const passingProps = (0, _utils.deepMergeObjects)(applyComponentPassingProps, componentStatePassingProps, sxComponentPassingProps.current, applySxStatePassingProps.current);
    const {
      sx: filteredComponentSx,
      rest: filteredComponentRemainingProps
    } = convertUtiltiyToSXFromProps(Object.assign(defaultComponentPropsWithoutVariants, inlineComponentPropsWithoutVariants), styledSystemProps, componentStyleConfig);
    let {
      sx: filteredPassingSx,
      rest: filteredPassingRemainingProps
    } = convertUtiltiyToSXFromProps((0, _utils.shallowMerge)({
      ...passingProps
    }, applyAncestorPassingProps), styledSystemProps, componentStyleConfig);
    let containsSX = false;
    Object.assign(applyComponentInlineProps, filteredPassingRemainingProps);
    Object.assign(applyComponentInlineProps, defaultResolvedInlineProps);
    Object.assign(applyComponentInlineProps, inlineResolvedInlineProps);
    Object.assign(applyComponentInlineProps, filteredComponentRemainingProps);
    if (Object.keys(filteredComponentSx).length > 0 || Object.keys(filteredPassingSx).length > 0) {
      containsSX = true;
    }
    let applyDescendantsStyleCSSIdsAndPropsWithKey = {};
    if (containsDescendant) {
      applyDescendantsStyleCSSIdsAndPropsWithKey = getMergeDescendantsStyleCSSIdsAndPropsWithKey(componentDescendantStyleIds, variantProps, theme, incomingComponentProps);
    }
    function injectAndUpdateSXProps(filteredPassingSx) {
      var _sxStyleIds$current2;
      if (Object.keys(filteredComponentSx).length > 0) {
        orderedComponentSXResolved = injectSx(filteredComponentSx, 'inline', styledContext.inlineStyleMap);
      }
      if (Object.keys(filteredPassingSx).length > 0) {
        orderedPassingSXResolved = injectSx(filteredPassingSx, 'passing', styledContext.inlineStyleMap);
      }
      const orderedSXResolved = [...orderedPassingSXResolved, ...orderedComponentSXResolved, ...BUILD_TIME_ORDERED_RESOLVED];
      // console.setStartTimeStamp('getStyleIds');
      sxStyleIds.current = (0, _getStyleIds.getStyleIds)(orderedSXResolved, componentStyleConfig);

      ///
      // Setting variants to sx property for inline variant resolution
      //@ts-ignore
      if (!sxStyleIds.current.component) {
        sxStyleIds.current.component = {};
      }
      sxStyleIds.current.component.variants = componentStyleIds.variants;
      //@ts-ignore
      sxStyleIds.current.component.compoundVariants = componentStyleIds.compoundVariants;
      // console.setStartTimeStamp('setColorModeBaseStyleIds');
      sxComponentStyleIds.current = (_sxStyleIds$current2 = sxStyleIds.current) === null || _sxStyleIds$current2 === void 0 ? void 0 : _sxStyleIds$current2.component;
      sxDescendantStyleIds.current = sxStyleIds.current.descendant;
      // 315ms
      // SX component style
      //@ts-ignore
      const {
        baseStyleCSSIds: sxBaseStyleCSSIds,
        variantStyleCSSIds: sxVariantStyleCSSIds,
        passingProps: sxPassingProps
      } = getMergedDefaultCSSIdsAndProps(
      //@ts-ignore
      sxComponentStyleIds.current, variantProps, theme, incomingComponentProps);
      //@ts-ignore
      // applySxStyleCSSIds.current = sxStyleCSSIds;
      //@ts-ignore
      applySxBaseStyleCSSIds.current = sxBaseStyleCSSIds;
      //@ts-ignore
      applySxVariantStyleCSSIds.current = sxVariantStyleCSSIds;
      sxComponentPassingProps.current = sxPassingProps;
    }
    if (containsSX) {
      injectAndUpdateSXProps(filteredPassingSx);
      const {
        componentBaseStyleFlatternStyleIdObject: a,
        componentVariantFlatternStyleIdObject: b,
        componentCompoundVariantFlatternStyleIdObject: c
      } = getFlattenStyleObjectFromStyleIds(sxComponentStyleIds.current);
      if (sxDescendantStyleIds.current && containsDescendant) {
        Object.keys(sxDescendantStyleIds.current).forEach(currentDescendant => {
          sxDescendantFlattenStyles.current[currentDescendant] = getFlattenStyleObjectFromStyleIds(sxDescendantStyleIds.current[currentDescendant]);
        });
      }
      sxBaseStyleFlatternStyleObject.current = a;
      sxVariantFlatternStyleObject.current = b;
      sxCompoundVariantFlatternStyleObject.current = c;

      //TODO: start: refactor for sx state + colormode + dynamic variable
      // for sx state props
      let stateColorMode = {};
      let currentStateArray = [];
      if (COLOR_MODE || states) {
        stateColorMode = {
          //@ts-ignore
          ...states,
          [COLOR_MODE]: true
        };
        currentStateArray = Object.keys(stateColorMode).filter(key => stateColorMode[key] === true);
      }

      // MUST REFACTOR: setStateAndColorModeCssIdsAndProps

      const {
        baseStyleCSSIds: mergedSXBaseStyleCSSIds,
        variantStyleCSSIds: mergedSXVariantStyleCSSIds,
        passingProps: mergedSxStateProps
      } = getMergedStateAndColorModeCSSIdsAndProps(sxComponentStyleIds.current,
      //@ts-ignore
      sxBaseStyleFlatternStyleObject.current, states, variantProps, COLOR_MODE, theme, sxVariantFlatternStyleObject.current, sxCompoundVariantFlatternStyleObject.current, currentStateArray);
      applySxStateVariantStyleCSSIds.current = mergedSXVariantStyleCSSIds;
      applySxStateBaseStyleCSSIds.current = mergedSXBaseStyleCSSIds;
      applySxStatePassingProps.current = mergedSxStateProps;
      const mergedSxDescendantsStyle = {};
      if (sxDescendantStyleIds.current) {
        Object.keys(sxDescendantStyleIds.current).forEach(key => {
          var _sxDescendantFlattenS4, _sxDescendantFlattenS5, _sxDescendantFlattenS6;
          const {
            baseStyleCSSIds: sxDescendantBaseStyleCSSIds,
            variantStyleCSSIds: sxDescendantVariantStyleCSSIds,
            passingProps: mergedPassingProps
          } = getMergedStateAndColorModeCSSIdsAndProps(
          //@ts-ignore
          sxDescendantStyleIds.current, (_sxDescendantFlattenS4 = sxDescendantFlattenStyles.current[key]) === null || _sxDescendantFlattenS4 === void 0 ? void 0 : _sxDescendantFlattenS4['componentBaseStyleFlatternStyleIdObject'], states, variantProps, COLOR_MODE, theme, (_sxDescendantFlattenS5 = sxDescendantFlattenStyles.current[key]) === null || _sxDescendantFlattenS5 === void 0 ? void 0 : _sxDescendantFlattenS5['componentVariantFlatternStyleIdObject'], (_sxDescendantFlattenS6 = sxDescendantFlattenStyles.current[key]) === null || _sxDescendantFlattenS6 === void 0 ? void 0 : _sxDescendantFlattenS6['componentCompoundVariantFlatternStyleIdObject'], currentStateArray);
          mergedSxDescendantsStyle[key] = {
            baseStyleCSSIds: sxDescendantBaseStyleCSSIds,
            variantStyleCSSIds: sxDescendantVariantStyleCSSIds,
            passingProps: mergedPassingProps
          };
        });
        applySxDescendantStateStyleCSSIdsAndPropsWithKey.current = mergedSxDescendantsStyle;
      }
      applySxStateBaseStyleCSSIds.current = mergedSXBaseStyleCSSIds;
      applySxDescendantStateStyleCSSIdsAndPropsWithKey.current = mergedSxDescendantsStyle;

      // applySxStatePassingProps.current = mergedSxStateProps;
      // mergedDescendantsStyle = _h;

      //////

      if (Object.keys(applySxStatePassingProps.current).length > 0 || Object.keys(sxComponentPassingProps.current).length > 0) {
        const passingPropsUpdated = {
          ...passingProps,
          ...sxComponentPassingProps.current,
          ...applySxStatePassingProps.current,
          ...applyAncestorPassingProps
        };
        const {
          sx: filteredPassingSxUpdated,
          rest: filteredPassingRemainingPropsUpdated
        } = convertUtiltiyToSXFromProps(passingPropsUpdated, styledSystemProps, componentStyleConfig);
        filteredPassingSx = filteredPassingSxUpdated;
        injectAndUpdateSXProps(filteredPassingSx);
        const resolvedPassingRemainingProps = resolveInlineProps(componentStyleConfig, componentExtendedConfig, filteredPassingRemainingPropsUpdated, CONFIG);

        // if (componentName === 'Switch') {
        //   console.log(
        //     // passingPropsUpdated,
        //     // resolvedPassingRemainingProps,
        //     resolvedInlineProps,
        //     // componentStyleConfig,
        //     '>>>>>>'
        //   );
        // }

        // Object.assign(applyComponentInlineProps, defaultResolvedInlineProps);
        // Object.assign(applyComponentInlineProps, filteredPassingRemainingProps);
        // Object.assign(applyComponentInlineProps, defaultInlineResolvedInlineProps);
        // Object.assign(applyComponentInlineProps, filteredComponentRemainingProps);

        Object.assign(applyComponentInlineProps, filteredPassingRemainingPropsUpdated);
        Object.assign(applyComponentInlineProps, resolvedPassingRemainingProps);
        Object.assign(applyComponentInlineProps, inlineResolvedInlineProps);
        Object.assign(applyComponentInlineProps, filteredComponentRemainingProps);
      }
    }
    if (containsDescendant) {
      //@ts-ignore
      applySxDescendantStyleCSSIdsAndPropsWithKey.current = getMergeDescendantsStyleCSSIdsAndPropsWithKey(sxDescendantStyleIds.current, variantProps, theme, incomingComponentProps);
    }
    const [applyComponentStateBaseStyleIds, setApplyComponentStateBaseStyleIds] = (0, _react.useState)(mergedBaseStyleCSSIds);

    // START: Unable to optimize because of useEffect overhead and stableHash to prevent rerender
    (0, _react.useEffect)(() => {
      (0, _colorMode.onChange)(colorMode => {
        // setCOLOR_MODE(colorMode);
        const {
          mergedBaseStyleCSSIds,
          mergedVariantStyleCSSIds,
          stateProps,
          mergedSXBaseStyleCSSIds,
          mergedSXVariantStyleCSSIds,
          mergedSxStateProps,
          mergedSxDescendantsStyle,
          mergedDescendantsStyle
        } = setStateAndColorModeCssIdsAndProps(colorMode, states, variantProps, theme, componentStyleIds, sxComponentStyleIds, componentBaseStyleFlatternStyleIdObject, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, componentDescendantFlattenStyles, sxBaseStyleFlatternStyleObject.current, sxVariantFlatternStyleObject, sxCompoundVariantFlatternStyleObject, sxDescendantFlattenStyles.current, componentDescendantStyleIds, sxDescendantStyleIds);
        setApplyComponentStateBaseStyleIds(mergedBaseStyleCSSIds);
        setApplyComponentStateVariantStyleIds(mergedVariantStyleCSSIds);
        setComponentStatePassingProps(stateProps);
        applySxStateBaseStyleCSSIds.current = mergedSXBaseStyleCSSIds;
        // setApplyStateSxBaseStyleCSSIds();
        applySxStateVariantStyleCSSIds.current = mergedSXVariantStyleCSSIds;
        applySxStatePassingProps.current = mergedSxStateProps;
        // setApplyStateSxVariantStyleCSSIds(mergedSXVariantStyleCSSIds);
        // setSxStatePassingProps(mergedSxStateProps);
        // setComponentStatePassingProps(stateProps);
        setApplyDescendantStateStyleCSSIdsAndPropsWithKey(mergedDescendantsStyle);
        applySxDescendantStateStyleCSSIdsAndPropsWithKey.current = mergedSxDescendantsStyle;
        // setApplySxDescendantStateStyleCSSIdsAndPropsWithKey(
        //   mergedSxDescendantsStyle
        // );
      });
      // remove onchage listener on unmount
      () => (0, _colorMode.onChange)(colorMode => {
        // setCOLOR_MODE(colorMode);
        setStateAndColorModeCssIdsAndProps(colorMode, states, variantProps, theme, componentStyleIds, sxComponentStyleIds, componentBaseStyleFlatternStyleIdObject, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, componentDescendantFlattenStyles, sxBaseStyleFlatternStyleObject.current, sxVariantFlatternStyleObject, sxCompoundVariantFlatternStyleObject, sxDescendantFlattenStyles.current, componentDescendantStyleIds, sxDescendantStyleIds);
      });
    }, []);
    (0, _react.useEffect)(() => {
      if (states && isClient.current) {
        const {
          mergedBaseStyleCSSIds,
          mergedVariantStyleCSSIds,
          stateProps,
          mergedSXBaseStyleCSSIds,
          mergedSXVariantStyleCSSIds,
          mergedSxStateProps,
          mergedSxDescendantsStyle,
          mergedDescendantsStyle
        } = setStateAndColorModeCssIdsAndProps(COLOR_MODE, states, variantProps, theme, componentStyleIds, sxComponentStyleIds, componentBaseStyleFlatternStyleIdObject, componentVariantFlatternStyleIdObject, componentCompoundVariantFlatternStyleIdObject, componentDescendantFlattenStyles, sxBaseStyleFlatternStyleObject.current, sxVariantFlatternStyleObject, sxCompoundVariantFlatternStyleObject, sxDescendantFlattenStyles.current, componentDescendantStyleIds, sxDescendantStyleIds);
        setApplyComponentStateBaseStyleIds(mergedBaseStyleCSSIds);
        setApplyComponentStateVariantStyleIds(mergedVariantStyleCSSIds);
        setComponentStatePassingProps(stateProps);
        applySxStateBaseStyleCSSIds.current = mergedSXBaseStyleCSSIds;
        // setApplyStateSxBaseStyleCSSIds(mergedSXBaseStyleCSSIds);
        applySxStateVariantStyleCSSIds.current = mergedSXVariantStyleCSSIds;
        // setApplyStateSxVariantStyleCSSIds(mergedSXVariantStyleCSSIds);
        applySxStatePassingProps.current = mergedSxStateProps;

        // setSxStatePassingProps(mergedSxStateProps);
        setApplyDescendantStateStyleCSSIdsAndPropsWithKey(mergedDescendantsStyle);
        applySxDescendantStateStyleCSSIdsAndPropsWithKey.current = mergedSxDescendantsStyle;
        // setApplySxDescendantStateStyleCSSIdsAndPropsWithKey(
        //   mergedSxDescendantsStyle
        // );
      }

      if (!isClient.current) {
        isClient.current = true;
      }
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [states]);

    // 600ms
    const descendantCSSIds = (0, _react.useMemo)(() => {
      if (!containsDescendant) {
        return {
          component: {},
          sx: {}
        };
      }
      const ids = (() => {
        if (applyDescendantsStyleCSSIdsAndPropsWithKey || applyDescendantStateStyleCSSIdsAndPropsWithKey || applySxDescendantStateStyleCSSIdsAndPropsWithKey.current || applySxDescendantStyleCSSIdsAndPropsWithKey || ancestorStyleContext) {
          const sxDescendantCSSIds = mergeArraysInObjects(ancestorStyleContext.sx, applySxDescendantStyleCSSIdsAndPropsWithKey.current, applySxDescendantStateStyleCSSIdsAndPropsWithKey.current);
          const componentDescendantCSSIds = mergeArraysInObjects(ancestorStyleContext.component, applyDescendantsStyleCSSIdsAndPropsWithKey, applyDescendantStateStyleCSSIdsAndPropsWithKey);
          return {
            component: componentDescendantCSSIds,
            sx: sxDescendantCSSIds
          };
        } else {
          return {
            component: {},
            sx: {}
          };
        }
      })();
      return ids;
    }, [(0, _stableHash.stableHash)(applyDescendantsStyleCSSIdsAndPropsWithKey), (0, _stableHash.stableHash)(applyDescendantStateStyleCSSIdsAndPropsWithKey), (0, _stableHash.stableHash)(applySxDescendantStateStyleCSSIdsAndPropsWithKey.current), ancestorStyleContext]);

    // 370ms

    // END: Unable to optimize because of useEffect overhead and stableHash to prevent rerender

    const styleCSSIds = [...applyBaseStyleCSSIds, ...applyAncestorBaseStyleCSSIds, ...applyVariantStyleCSSIds, ...applyAncestorVariantStyleCSSIds, ...applyComponentStateBaseStyleIds, ...applyComponentStateVariantStyleIds, ...applySxAncestorBaseStyleCSSIds, ...applySxAncestorVariantStyleCSSIds,
    // ...applySxAncestorBaseStyleCSSIds,
    ...applySxVariantStyleCSSIds.current, ...applySxStateVariantStyleCSSIds.current, ...applySxBaseStyleCSSIds.current, ...applySxStateBaseStyleCSSIds.current];

    // Object.assign(resolvedInlineProps, applyComponentInlineProps);

    const resolvedStyleProps = (0, _generateStylePropsFromCSSIds.generateStylePropsFromCSSIds)(applyComponentInlineProps, styleCSSIds, CONFIG, activeTheme);
    const AsComp = resolvedStyleProps.as || passingProps.as || undefined;
    let resolvedStyleMemo = [passingProps === null || passingProps === void 0 ? void 0 : passingProps.style, ...(resolvedStyleProps === null || resolvedStyleProps === void 0 ? void 0 : resolvedStyleProps.style)];
    if (_reactNative.Platform.OS === 'web') {
      resolvedStyleMemo = _reactNative.StyleSheet.flatten(resolvedStyleMemo);
    }
    resolvedStyleProps === null || resolvedStyleProps === void 0 || delete resolvedStyleProps.as;

    // }

    const ComponentWithPlugin = _react.default.useMemo(() => {
      if (plugins) {
        for (const pluginName in plugins) {
          var _plugins$pluginName2;
          // @ts-ignore
          if ((_plugins$pluginName2 = plugins[pluginName]) !== null && _plugins$pluginName2 !== void 0 && _plugins$pluginName2.componentMiddleWare) {
            var _plugins$pluginName3, _Component;
            // @ts-ignore
            Component = (_plugins$pluginName3 = plugins[pluginName]) === null || _plugins$pluginName3 === void 0 ? void 0 : _plugins$pluginName3.componentMiddleWare({
              Component: Component,
              theme,
              componentStyleConfig,
              ExtendedConfig
            });

            //@ts-ignore
            pluginData = {
              ...pluginData,
              ...((_Component = Component) === null || _Component === void 0 ? void 0 : _Component.styled)
            };
          }
        }
      }
      return Component;
    }, []);
    let component;
    const propsToBePassedInToPlugin = (plugins === null || plugins === void 0 ? void 0 : plugins.length) > 0 ? {
      ...variantProps,
      sx: componentProps.sx
    } : {};
    if (AsComp) {
      //@ts-ignore
      if (Component.isStyledComponent) {
        component = /*#__PURE__*/_react.default.createElement(ComponentWithPlugin, _extends({}, resolvedStyleProps, propsToBePassedInToPlugin, {
          style: resolvedStyleMemo,
          as: AsComp,
          ref: ref
        }), children);
      } else {
        component = /*#__PURE__*/_react.default.createElement(AsComp, _extends({}, resolvedStyleProps, {
          style: resolvedStyleMemo,
          ref: ref
        }), children);
      }
    } else {
      component = /*#__PURE__*/_react.default.createElement(ComponentWithPlugin, _extends({}, resolvedStyleProps, propsToBePassedInToPlugin, {
        style: resolvedStyleMemo,
        ref: ref
      }), children);
    }
    if (containsDescendant) {
      return /*#__PURE__*/_react.default.createElement(AncestorStyleContext.Provider, {
        value: descendantCSSIds
      }, component);
    }
    return component;
  };
  const StyledComp = /*#__PURE__*/_react.default.forwardRef(StyledComponent);

  //@ts-ignore
  StyledComp.getStyledData = () => pluginData;
  const displayName = componentStyleConfig !== null && componentStyleConfig !== void 0 && componentStyleConfig.componentName ? componentStyleConfig === null || componentStyleConfig === void 0 ? void 0 : componentStyleConfig.componentName : (_Component2 = Component) === null || _Component2 === void 0 ? void 0 : _Component2.displayName;
  StyledComp.displayName = displayName ? 'Styled' + displayName : 'StyledComponent';

  //@ts-ignore
  StyledComp.isStyledComponent = true;
  return StyledComp;
}
function styled(Component, theme, componentStyleConfig, ExtendedConfig, BUILD_TIME_PARAMS) {
  const nonVerbosedTheme = theme;
  // const DEBUG_TAG = componentStyleConfig?.DEBUG;
  // const DEBUG =
  //   process.env.NODE_ENV === 'development' && DEBUG_TAG ? false : false;

  // const componentName = componentStyleConfig?.componentName;
  // const componentExtendedTheme = extendedThemeConfig?.theme;
  // const componentExtended_build_time_params =
  //   extendedThemeConfig?.BUILD_TIME_PARAMS;
  // let mergedBuildTimeParams: any;

  if (BUILD_TIME_PARAMS) {
    // mergedBuildTimeParams = deepMergeArray(
    //   { ...BUILD_TIME_PARAMS },
    //   { ...componentExtended_build_time_params }
    // );
  }

  // let styledObj = { ...theme };
  // if (componentExtendedTheme) {
  //   styledObj = deepMerge({ ...theme }, { ...componentExtendedTheme });
  // }

  // // move inside stylehash created
  // let plugins = [...getInstalledPlugins()];

  // if (ExtendedConfig?.plugins) {
  //   // @ts-ignore
  //   plugins = [...plugins, ...ExtendedConfig?.plugins];
  // }

  // for (const pluginName in plugins) {
  //   // @ts-ignore
  //   [styledObj, , , Component] = plugins[pluginName]?.inputMiddleWare<P>(
  //     styledObj,
  //     true,
  //     true,
  //     Component
  //   );
  // }

  // theme = styledObj;

  // move inside stylehash created

  const sxConvertedObject = (0, _convertSxToSxVerbosed.convertStyledToStyledVerbosed)(theme);
  let StyledComponent = verboseStyled(Component, sxConvertedObject, componentStyleConfig, ExtendedConfig, BUILD_TIME_PARAMS, nonVerbosedTheme);

  // @ts-ignore
  StyledComponent.isAnimatedComponent = Component.isAnimatedComponent;

  // move before returning component from verboseStyled

  // @ts-ignore
  // plugins?.reverse();
  // for (const pluginName in plugins) {
  //   // @ts-ignore
  //   if (plugins[pluginName]?.componentMiddleWare) {
  //     // @ts-ignore
  //     StyledComponent = plugins[pluginName]?.componentMiddleWare({
  //       Component: StyledComponent,
  //       theme,
  //       componentStyleConfig,
  //       ExtendedConfig,
  //     });
  //   }
  // }
  // move before returning component from verboseStyled

  // for (const pluginName in plugins) {
  //   const compWrapper =
  //     // @ts-ignore
  //     typeof plugins[pluginName].wrapperComponentMiddleWare === 'function'
  //       ? // @ts-ignore
  //         plugins[pluginName].wrapperComponentMiddleWare()
  //       : null;

  //   if (compWrapper) {
  //     for (const key of Object.keys(compWrapper)) {
  //       // @ts-ignore
  //       StyledComponent[key] = compWrapper[key];
  //     }
  //   }
  // }

  return StyledComponent;
}
//# sourceMappingURL=styled.js.map