"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateStylePropsFromCSSIds = generateStylePropsFromCSSIds;
exports.getClosestBreakpoint = getClosestBreakpoint;
exports.getClosestBreakpointValue = getClosestBreakpointValue;
exports.isValidBreakpoint = isValidBreakpoint;
var _reactNative = require("react-native");
var _styleSheet = require("./style-sheet");
var _utils = require("./utils");
function getClosestBreakpoint(values, point) {
  const dimValues = Object.values(values);
  let index = -1;
  let breakpointsObj = {};
  for (let i = 0; i < dimValues.length; i++) {
    breakpointsObj[dimValues[i]] = i;
  }
  const breakpoints = Object.keys(breakpointsObj);
  for (let i = 0; i < breakpoints.length; i++) {
    if (parseInt(breakpoints[i]) === point) {
      index = breakpointsObj[breakpoints[i]];
      break;
    } else if (parseInt(breakpoints[i]) > point && i !== 0) {
      index = breakpointsObj[breakpoints[i - 1]];
      break;
    }
    // If windowWidth is greater than last available breakpoint clamp it to last index
    else if (parseInt(breakpoints[i]) < point && i === dimValues.length - 1) {
      index = breakpointsObj[breakpoints[i]];
      break;
    }
  }
  return breakpoints[index];
}
function getMinWidthFromMediaQuery(mediaQuery) {
  const regex = /\(\s*min-width:\s*(\d+)px\s*\)/;
  const matches = regex.exec(mediaQuery);
  if (matches) {
    return parseInt(matches[1], 10);
  }
  return 0;
}
function getClosestBreakpointValue(mediaQueries, value) {
  if (!mediaQueries) return;
  const dimValues = Object.values(mediaQueries);
  let index = -1;
  let breakpointsObj = {};
  for (let i = 0; i < dimValues.length; i++) {
    const minWidth = getMinWidthFromMediaQuery(dimValues[i]);
    breakpointsObj[minWidth] = dimValues[i];
  }
  const breakpoints = Object.keys(breakpointsObj);
  for (let i = 0; i < breakpoints.length; i++) {
    if (parseInt(breakpoints[i]) === value) {
      index = breakpoints[i];
      break;
    } else if (parseInt(breakpoints[i]) > value && i !== 0) {
      index = breakpoints[i - 1];
      break;
    }
    // If windowWidth is greater than last available breakpoint clamp it to last index
    else if (parseInt(breakpoints[i]) < value && i === dimValues.length - 1) {
      index = breakpoints[i];
      break;
    }
  }
  return index;
}
function isValidBreakpoint(config, queryCondition) {
  var _Dimensions$get;
  let width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (_Dimensions$get = _reactNative.Dimensions.get('window')) === null || _Dimensions$get === void 0 ? void 0 : _Dimensions$get.width;
  const windowWidth = width;
  const currentBreakpointValue = getClosestBreakpointValue(config.tokens.mediaQueries, windowWidth);
  const queryWidth = (0, _utils.extractWidthValues)(queryCondition);
  if (queryWidth.length > 0) {
    if (queryWidth.length === 1) {
      if (queryWidth[0] !== null && queryWidth[0] <= currentBreakpointValue) {
        return true;
      }
    } else {
      if (currentBreakpointValue >= queryWidth[0] && currentBreakpointValue <= queryWidth[1]) {
        return true;
      }
    }
  }
  return false;
}
function getDataStyle(props, styleCSSIdsString) {
  if (_reactNative.Platform.OS === 'web') {
    var _props$dataSet, _props$dataSet2;
    if (props !== null && props !== void 0 && (_props$dataSet = props.dataSet) !== null && _props$dataSet !== void 0 && _props$dataSet.style && props !== null && props !== void 0 && props['data-style']) {
      return props['data-style'] + ' ' + props.dataSet.style + ' ' + styleCSSIdsString;
    } else if (props !== null && props !== void 0 && (_props$dataSet2 = props.dataSet) !== null && _props$dataSet2 !== void 0 && _props$dataSet2.style) {
      return props.dataSet.style + ' ' + styleCSSIdsString;
    } else if (props !== null && props !== void 0 && props['data-style']) {
      return props['data-style'] + ' ' + styleCSSIdsString;
    } else {
      return styleCSSIdsString;
    }
  } else {
    return '';
  }
}
function generateStylePropsFromCSSIds(props, styleCSSIds, config, activeTheme) {
  const propsStyles = Array.isArray(props === null || props === void 0 ? void 0 : props.style) ? props === null || props === void 0 ? void 0 : props.style : [props === null || props === void 0 ? void 0 : props.style];

  // for RN
  const styleObj = [];
  let styleCSSIdsString = '';
  if (styleCSSIds.length > 0) {
    if (_reactNative.Platform.OS !== 'web') {
      const nativeStyleMap = _styleSheet.GluestackStyleSheet.getStyleMap();
      styleCSSIds.forEach(cssId => {
        const nativeStyle = nativeStyleMap.get(cssId);
        if (nativeStyle) {
          var _nativeStyle$meta;
          const queryCondition = nativeStyle === null || nativeStyle === void 0 || (_nativeStyle$meta = nativeStyle.meta) === null || _nativeStyle$meta === void 0 ? void 0 : _nativeStyle$meta.queryCondition;
          const styleSheet = nativeStyle === null || nativeStyle === void 0 ? void 0 : nativeStyle.resolved;
          if (queryCondition) {
            if (isValidBreakpoint(config, queryCondition)) {
              styleObj.push(styleSheet);
            }
          } else {
            styleObj.push(styleSheet);
          }
          if (nativeStyle.meta.themeCondition && activeTheme) {
            styleObj.push({
              ...nativeStyle.meta.themeCondition[activeTheme]
            });
          }
        }
      });
    } else {
      styleCSSIdsString = styleCSSIds.join(' ');
    }
  }
  Object.assign(props, {
    'style': propsStyles ? [...styleObj, ...propsStyles] : styleObj,
    'dataSet': {
      ...(props === null || props === void 0 ? void 0 : props.dataSet),
      style: getDataStyle(props, styleCSSIdsString)
    },
    // DONOT REMOVE THIS LINE, THIS IS FOR SPECIFIC COMPONENTS LIKE next/link
    'data-style': getDataStyle(props, styleCSSIdsString)
  });
  return props;
}
//# sourceMappingURL=generateStylePropsFromCSSIds.js.map