"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createConfig = exports.createComponents = void 0;
exports.getInstalledComponents = getInstalledComponents;
exports.resolveTheme = exports.resolveComponentThemes = exports.resolveComponentTheme = void 0;
var _convertSxToSxVerbosed = require("./convertSxToSxVerbosed");
var _utils = require("./utils");
var _stableHash = require("./stableHash");
var _propertyTokenMap = require("./propertyTokenMap");
var _updateOrderUnResolvedMap = require("./updateOrderUnResolvedMap");
var _styleSheet = require("./style-sheet");
var _styled = require("./styled");
var _reactNative = require("react-native");
/********************* PLUGINS *****************************/

// var globalPluginStore: never[] = [];
// function setGlobalPluginStore(plugins: any) {
//   if (plugins) {
//     // @ts-ignore
//     globalPluginStore.push(...plugins);
//   }
//   return getGlobalPluginStore();
// }
// function getGlobalPluginStore() {
//   return globalPluginStore;
// }

// export function getInstalledPlugins() {
//   return getGlobalPluginStore();
// }
/********************* CREATE COMPONENTS *****************************/
var globalComponentsStore = {};

// function setGlobalComponentsStore(components: any) {
//   if (components) {
//     // @ts-ignore
//     globalComponentsStore = {
//       ...globalComponentsStore,
//       ...components,
//     };
//   }
//   return getGlobalComponentsStore();
// }

function getGlobalComponentsStore() {
  return globalComponentsStore;
}
function getInstalledComponents() {
  return getGlobalComponentsStore();
}
const createComponents = components => {
  return components;
};
exports.createComponents = createComponents;
const createConfig = config => {
  if (config.plugins) {
    // config.plugins = setGlobalPluginStore(config.plugins);
  }
  // delete config.plugins;

  if (!config.themes) {
    return config;
  }
  // if (config.components) {
  //   newConfig = resolveComponentThemes(config);
  // }

  if (config.themes) {
    const newConfigWithThemesResolved = resolveThemes(config);
    return newConfigWithThemesResolved;
  }
  return config;
};
exports.createConfig = createConfig;
const resolveThemes = config => {
  const newConfig = {
    ...config
  };
  Object.keys((newConfig === null || newConfig === void 0 ? void 0 : newConfig.themes) ?? {}).forEach(themeName => {
    let theme = newConfig.themes[themeName];
    Object.keys(theme).forEach(tokenScale => {
      const tokenScaleValue = theme[tokenScale];
      Object.keys(tokenScaleValue).forEach(token => {
        const tokenValue = (0, _utils.resolveStringToken)(tokenScaleValue[token], newConfig, tokenScale, '');
        tokenScaleValue[token] = tokenValue;
      });
    });
    // const tempCONFIG = JSON.parse(JSON.stringify(newConfig));
    // delete tempCONFIG.themes;
    // deepMerge(tempCONFIG, { tokens: { ...theme } });
    // newConfig.themes[themeName] = tempCONFIG;
  });

  return newConfig;
};
const resolveComponentTheme = (config, componentTheme) => {
  const configWithPropertyTokenMap = config;
  let resolvedTheme = componentTheme;
  const component = componentTheme;
  if (Object.keys((component === null || component === void 0 ? void 0 : component.BUILD_TIME_PARAMS) ?? {}).length === 0 && component.theme) {
    resolvedTheme = resolveTheme(component.theme, configWithPropertyTokenMap, component === null || component === void 0 ? void 0 : component.componentConfig);
  } else {
    var _component$BUILD_TIME;
    _styleSheet.GluestackStyleSheet.update((_component$BUILD_TIME = component.BUILD_TIME_PARAMS) === null || _component$BUILD_TIME === void 0 ? void 0 : _component$BUILD_TIME.orderedResolved);
    resolvedTheme = component;
  }
  return resolvedTheme;
};
exports.resolveComponentTheme = resolveComponentTheme;
const resolveComponentThemes = (config, components) => {
  let newComponents = {};
  const configWithPropertyTokenMap = {
    ...config,
    propertyTokenMap: _propertyTokenMap.propertyTokenMap
  };
  Object.keys(components ?? {}).forEach(componentName => {
    const component = components[componentName];
    if (Object.keys((component === null || component === void 0 ? void 0 : component.BUILD_TIME_PARAMS) ?? {}).length === 0 && component.theme) {
      newComponents[componentName] = resolveTheme(component.theme, configWithPropertyTokenMap, component === null || component === void 0 ? void 0 : component.componentConfig);
    } else {
      var _component$BUILD_TIME2;
      _styleSheet.GluestackStyleSheet.update((_component$BUILD_TIME2 = component.BUILD_TIME_PARAMS) === null || _component$BUILD_TIME2 === void 0 ? void 0 : _component$BUILD_TIME2.orderedResolved);
      newComponents[componentName] = component;
    }
  });
  return newComponents;
};
exports.resolveComponentThemes = resolveComponentThemes;
const resolveTheme = (componentTheme, _config, extendedConfig) => {
  const versboseComponentTheme = (0, _convertSxToSxVerbosed.convertStyledToStyledVerbosed)(componentTheme);
  (0, _styled.resolvePlatformTheme)(versboseComponentTheme, _reactNative.Platform.OS);
  const componentHash = (0, _stableHash.stableHash)({
    ...versboseComponentTheme
  });
  const {
    styledIds,
    verbosedStyleIds
  } = (0, _updateOrderUnResolvedMap.updateOrderUnResolvedMap)(versboseComponentTheme, componentHash, 'extended', extendedConfig);
  return {
    styledIds,
    verbosedStyleIds,
    theme: versboseComponentTheme
  };
};
exports.resolveTheme = resolveTheme;
//# sourceMappingURL=createConfig.js.map