"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "flush", {
  enumerable: true,
  get: function () {
    return _cssInjector.flush;
  }
});
exports.injectCssVariablesGlobalStyle = injectCssVariablesGlobalStyle;
exports.injectGlobalCssStyle = injectGlobalCssStyle;
exports.injectInStyle = injectInStyle;
var _cssInjector = require("./utils/css-injector");
function createCssVariables(tokens) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'gluestack-';
  let cssVariables = '';
  for (const [key, value] of Object.entries(tokens)) {
    const variableName = `${prefix}${key}`;
    if (typeof value === 'object') {
      cssVariables += createCssVariables(value, `${variableName}-`);
    } else {
      cssVariables += `--${variableName}: ${value};\n`;
    }
  }
  return cssVariables;
}
function injectGlobalCssStyle(css) {
  let styleTagId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'css-injected-global';
  (0, _cssInjector.injectGlobalCss)(css, styleTagId);
}
function injectCssVariablesGlobalStyle(componentExtendedConfig) {
  (0, _cssInjector.injectGlobalCss)(`:root {${createCssVariables(componentExtendedConfig.tokens)}\n};`);
}
function injectInStyle(_globalStyleMap) {
  _globalStyleMap.forEach((componentThemeHash, componentThemeHashKey) => {
    componentThemeHash.forEach((componentThemes, componentThemesKey) => {
      let toBeInjectedCssRules = '';
      componentThemes.forEach(componentTheme => {
        var _componentTheme$meta;
        const cssRuleset = componentTheme === null || componentTheme === void 0 || (_componentTheme$meta = componentTheme.meta) === null || _componentTheme$meta === void 0 ? void 0 : _componentTheme$meta.cssRuleset;
        if (cssRuleset) {
          toBeInjectedCssRules += cssRuleset;
        }
      });
      if (toBeInjectedCssRules) {
        (0, _cssInjector.inject)(`@media screen {${toBeInjectedCssRules}}`, componentThemeHashKey, componentThemesKey);
      }
    });
  });

  // _globalStyleMap?.forEach((values: any, key: any) => {
  //   values?.forEach((value: any) => {
  //     value?.forEach((currVal: any) => {
  //       const styleTagId = Object.keys(currVal)[0];

  //       const orderedResolved = currVal[styleTagId];

  //       let toBeInjectedCssRules = '';
  //       Object.keys(orderedResolved)?.map((orderResolvedKey) => {
  //         const finalOrderResolved = Object.keys(
  //           orderedResolved[orderResolvedKey]
  //         )[0];

  //         const cssRuleset =
  //           orderedResolved?.[orderResolvedKey]?.[finalOrderResolved]?.value;

  //         if (cssRuleset) {
  //           toBeInjectedCssRules += cssRuleset;
  //         }
  //       });
  //       if (toBeInjectedCssRules) {
  //         inject(
  //           `@media screen {${toBeInjectedCssRules}}`,
  //           key as any,
  //           styleTagId
  //         );
  //       }
  //     });
  //   });
  // });
}
//# sourceMappingURL=injectInStyle.web.js.map