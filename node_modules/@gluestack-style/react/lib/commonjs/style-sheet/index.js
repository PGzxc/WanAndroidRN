"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StyleInjector = exports.GluestackStyleSheet = void 0;
var _resolver = require("../resolver");
var _updateCSSStyleInOrderedResolved = require("../updateCSSStyleInOrderedResolved.web");
var _utils = require("../utils");
var _cssInjector = require("../utils/css-injector");
class StyleInjector {
  #globalStyleMap;
  constructor() {
    this.#globalStyleMap = new Map();
  }
  declare(orderedSXResolved, _wrapperElementId) {
    let _styleTagId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'css-injected-boot-time';
    let extendedConfig = arguments.length > 3 ? arguments[3] : undefined;
    const styleIds = [];
    orderedSXResolved.forEach(styledResolved => {
      var _styledResolved$meta;
      if (styledResolved !== null && styledResolved !== void 0 && (_styledResolved$meta = styledResolved.meta) !== null && _styledResolved$meta !== void 0 && _styledResolved$meta.cssId) {
        this.#globalStyleMap.set(styledResolved.meta.cssId, {
          ...styledResolved,
          type: _wrapperElementId,
          componentHash: _styleTagId,
          extendedConfig
        });
        styleIds.push(styledResolved.meta.cssId);
      }
    });
    return styleIds;
  }
  resolve() {
    let cssIds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let CONFIG = arguments.length > 1 ? arguments[1] : undefined;
    let ExtendedConfig = arguments.length > 2 ? arguments[2] : undefined;
    let resolve = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    let declarationType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'boot';
    let componentExtendedConfig = CONFIG;
    if (ExtendedConfig) {
      componentExtendedConfig = (0, _utils.deepMerge)(CONFIG, ExtendedConfig);
    }
    const toBeInjected = {};
    cssIds === null || cssIds === void 0 || cssIds.forEach(cssId => {
      if (this.#globalStyleMap.get(cssId)) {
        const styledResolved = this.#globalStyleMap.get(cssId);
        const theme = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.original;
        if (resolve) {
          this.resolveComponentTheme(styledResolved, theme, componentExtendedConfig, styledResolved.componentHash, CONFIG, declarationType);
        }
        if (!toBeInjected[styledResolved.type]) toBeInjected[styledResolved.type] = {};
        if (!toBeInjected[styledResolved.type][styledResolved.componentHash]) toBeInjected[styledResolved.type][styledResolved.componentHash] = '';
        toBeInjected[styledResolved.type][styledResolved.componentHash] += styledResolved.meta.cssRuleset;

        // this.injectStyles(
        //   styledResolved.meta.cssRuleset,
        //   styledResolved?.type,
        //   styledResolved?.componentHash
        // );
        if (styledResolved) {
          this.#globalStyleMap.set(styledResolved.meta.cssId, {
            ...styledResolved,
            value: styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.resolved
          });
        }
      }
    });
    return toBeInjected;
  }
  update(orderResolvedStyleMap) {
    const toBeInjected = {};
    orderResolvedStyleMap.forEach(styledResolved => {
      this.#globalStyleMap.set(styledResolved.meta.cssId, styledResolved);
      if (!toBeInjected[styledResolved.type]) toBeInjected[styledResolved.type] = {};
      if (!toBeInjected[styledResolved.type][styledResolved.componentHash]) toBeInjected[styledResolved.type][styledResolved.componentHash] = '';
      toBeInjected[styledResolved.type][styledResolved.componentHash] += styledResolved.meta.cssRuleset;
    });
    return toBeInjected;
  }
  inject() {
    let toBeInjected = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let inlineStyleMap = arguments.length > 1 ? arguments[1] : undefined;
    Object.keys(toBeInjected).forEach(type => {
      Object.keys(toBeInjected[type]).forEach(styleTag => {
        this.injectStyles(toBeInjected[type][styleTag], type, styleTag, inlineStyleMap);
      });
    });
  }
  resolveComponentTheme(componentTheme, theme, componentExtendedConfig, componentHashKey, CONFIG) {
    let declarationType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'boot';
    const prefixClassName = declarationType === 'inline' ? 'gs' : '';
    componentTheme.resolved = (0, _resolver.StyledValueToCSSObject)(theme, componentExtendedConfig);
    (0, _utils.addThemeConditionInMeta)(componentTheme, CONFIG);

    // delete componentTheme.meta.cssRuleset;

    if (componentTheme.meta && componentTheme.meta.queryCondition) {
      var _resolveTokensFromCon;
      // console.log(
      //   JSON.parse(JSON.stringify(CONFIG)),
      //   componentTheme.meta,
      //   componentTheme.meta.queryCondition
      // );

      const queryCondition = (_resolveTokensFromCon = (0, _utils.resolveTokensFromConfig)(CONFIG, {
        condition: componentTheme.meta.queryCondition
      })) === null || _resolveTokensFromCon === void 0 ? void 0 : _resolveTokensFromCon.condition;
      // console.log(JSON.parse(JSON.stringify(CONFIG)), queryCondition);

      componentTheme.meta.queryCondition = queryCondition;
    }
    const cssData = (0, _updateCSSStyleInOrderedResolved.getCSSIdAndRuleset)(componentTheme, componentHashKey, prefixClassName);
    componentTheme.meta.cssRuleset = cssData.rules.style;
  }
  getStyleMap() {
    return this.#globalStyleMap;
  }
  injectStyles(cssRuleset, _wrapperType, _styleTagId, inlineStyleMap) {
    if (cssRuleset) {
      (0, _cssInjector.inject)(`@media screen {${cssRuleset}}`, _wrapperType, _styleTagId, inlineStyleMap);
    }
  }
}
exports.StyleInjector = StyleInjector;
const stylesheet = new StyleInjector();
const GluestackStyleSheet = stylesheet;
exports.GluestackStyleSheet = GluestackStyleSheet;
//# sourceMappingURL=index.js.map