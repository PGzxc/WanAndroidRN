"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertStyledToStyledVerbosed = convertStyledToStyledVerbosed;
exports.convertSxToSxVerbosed = convertSxToSxVerbosed;
exports.resolveStyledPropsRecursively = resolveStyledPropsRecursively;
const STATE = 'state';
const STYLE = 'style';
const PROPS = 'props';
const DESCENDANTS = 'descendants';

// ------------------------------------------- Reserved keys -------------------------------------------
const reservedKeys = {
  state: {
    ':indeterminate': 'indeterminate',
    ':checked': 'checked',
    ':readOnly': 'readOnly',
    ':required': 'required',
    ':invalid': 'invalid',
    ':focus': 'focus',
    ':focusVisible': 'focusVisible',
    ':hover': 'hover',
    ':pressed': 'pressed',
    ':active': 'active',
    ':loading': 'loading',
    ':disabled': 'disabled'
  },
  colorMode: {
    _light: 'light',
    _dark: 'dark'
  },
  platform: {
    _web: 'web',
    _ios: 'ios',
    _android: 'android'
  }
};

//------------------------------------------- Helper function -------------------------------------------
const getObjectParentProperty = function (obj, key) {
  let prevKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  for (const prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      if (prop === key) {
        return prevKey;
      }
      if (obj[prop] && typeof obj[prop] === 'object') {
        const result = getObjectParentProperty(obj[prop], key, prop);
        if (result) {
          return result;
        }
      }
    }
  }
  return null;
};
const setObjectKeyValue = (obj, keys, value) => {
  var _keys;
  if (!Array.isArray(keys)) {
    keys = [keys];
  }
  let current = obj;
  (_keys = keys) === null || _keys === void 0 || _keys.forEach((key, index) => {
    var _keys2;
    if (index === ((_keys2 = keys) === null || _keys2 === void 0 ? void 0 : _keys2.length) - 1) {
      current[key] = value;
    } else {
      if (!current[key]) {
        current[key] = {};
      }
      current = current[key];
    }
  });
  return obj;
};

// ------------------------------------------- Responsive props resolution -------------------------------------------
const resolveResponsiveProps = (sxVerbosed, breakpoint, path, prop, responsiveStyle) => {
  const sxResolvedResponsiveProp = setObjectKeyValue({}, path, responsiveStyle[prop]);
  if (sxVerbosed.queries) {
    var _sxVerbosed$queries;
    const existingBeakpointIndex = sxVerbosed === null || sxVerbosed === void 0 || (_sxVerbosed$queries = sxVerbosed.queries) === null || _sxVerbosed$queries === void 0 ? void 0 : _sxVerbosed$queries.findIndex(data => data.condition === breakpoint);
    if (existingBeakpointIndex !== -1) {
      setObjectKeyValue(sxVerbosed.queries[existingBeakpointIndex].value, path, responsiveStyle[prop]);
    } else {
      var _sxVerbosed$queries2;
      sxVerbosed === null || sxVerbosed === void 0 || (_sxVerbosed$queries2 = sxVerbosed.queries) === null || _sxVerbosed$queries2 === void 0 || _sxVerbosed$queries2.push({
        condition: breakpoint,
        value: sxResolvedResponsiveProp
      });
    }
  } else {
    var _sxVerbosed$queries3;
    sxVerbosed.queries = [];
    sxVerbosed === null || sxVerbosed === void 0 || (_sxVerbosed$queries3 = sxVerbosed.queries) === null || _sxVerbosed$queries3 === void 0 || _sxVerbosed$queries3.push({
      condition: breakpoint,
      value: sxResolvedResponsiveProp
    });
  }
};

// ------------------------------------------- sx to sx verbosed resolution -------------------------------------------

function resolveStyledPropsRecursively() {
  let theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let sxVerbosed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let breakpoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  // console.setStartTimeStamp('resolvedStyledPropsRecursively', 'boot');

  const themeKeys = Object.keys(theme);
  themeKeys === null || themeKeys === void 0 || themeKeys.forEach(prop => {
    if (reservedKeys.state[prop]) {
      path.push(STATE, prop.slice(1));
      resolveStyledPropsRecursively(theme[prop], path, sxVerbosed, breakpoint);
      path.pop();
      path.pop();
    } else if (prop !== null && prop !== void 0 && prop.startsWith('_')) {
      const parentProperty = getObjectParentProperty(reservedKeys, prop);
      if (parentProperty) {
        path.push(parentProperty, prop.slice(1));
      } else {
        path.push(DESCENDANTS, prop);
      }
      resolveStyledPropsRecursively(theme[prop], path, sxVerbosed, breakpoint);
      path.pop();
      path.pop();
    } else if (prop !== null && prop !== void 0 && prop.startsWith('@')) {
      const breakpointValue = `$${prop.slice(1)}`;
      resolveStyledPropsRecursively(theme[prop], path, sxVerbosed, breakpointValue);
    } else if (prop === 'props') {
      const propValue = theme[prop];
      path.push(PROPS);
      setObjectKeyValue(sxVerbosed, path, propValue);
      path.pop();
    } else {
      const propValue = theme[prop];
      path.push(STYLE, prop);
      if (breakpoint) {
        resolveResponsiveProps(sxVerbosed, breakpoint, path, prop, theme);
      } else {
        setObjectKeyValue(sxVerbosed, path, propValue);
      }
      path.pop();
      path.pop();
    }
  });

  //if (theme.props) console.log(sxVerbosed);
  // console.setEndTimeStamp('resolvedStyledPropsRecursively', 'boot');
  return sxVerbosed;
}

// ------------------------------------------- Variant & Size resolution -------------------------------------------

function resolveVariantSize(theme) {
  // console.setStartTimeStamp('resolveVariantSize');

  if (!theme) return {};
  const themeKey = Object === null || Object === void 0 ? void 0 : Object.keys(theme);
  const verbosedVariantAndSize = {};
  themeKey === null || themeKey === void 0 || themeKey.map(prop => {
    const sxVerbosedConvertedProps = resolveStyledPropsRecursively(theme[prop]);
    setObjectKeyValue(verbosedVariantAndSize, [prop], sxVerbosedConvertedProps);
  });

  // console.setEndTimeStamp('resolveVariantSize');
  return verbosedVariantAndSize;
}

// ------------------------------------------- sx to verbosed final props -------------------------------------------

function convertStyledToStyledVerbosed(theme) {
  // console.setStartTimeStamp('converStyledToStyledVerbosed', 'boot');

  const {
    variants = {},
    compoundVariants = [],
    defaultProps = {},
    ...restTheme
  } = theme;
  const verbosedStyledTheme = {
    baseStyle: {},
    variants: {},
    compoundVariants: []
  };
  const sxConvertedBaseStyle = resolveStyledPropsRecursively(restTheme);
  setObjectKeyValue(verbosedStyledTheme, 'baseStyle', sxConvertedBaseStyle);
  Object.keys(variants).forEach(variant => {
    const variantType = variants[variant];
    const sxConvertedVariant = resolveVariantSize(variantType);
    setObjectKeyValue(verbosedStyledTheme.variants, variant, sxConvertedVariant);
  });
  compoundVariants.forEach(compoundVariant => {
    const sxConvertedCompoundVariantValue = resolveStyledPropsRecursively(compoundVariant.value);
    const sxConvertedCompoundVariant = {
      ...compoundVariant,
      value: sxConvertedCompoundVariantValue
    };
    verbosedStyledTheme.compoundVariants.push(sxConvertedCompoundVariant);
  });
  if (defaultProps) {
    if (verbosedStyledTheme.baseStyle.props) {
      verbosedStyledTheme.baseStyle.props = {
        ...verbosedStyledTheme.baseStyle.props,
        ...defaultProps
      };
    } else {
      verbosedStyledTheme.baseStyle.props = {
        ...defaultProps
      };
    }
  }

  /*
   // Removing the feature 
   if (restTheme.defaultProps) {
    verbosedStyledTheme.props = restTheme.defaultProps || {};
  } else if (restTheme.props) {
    verbosedStyledTheme.props = restTheme.props || {};
  }
  */
  // console.setEndTimeStamp('converStyledToStyledVerbosed', 'boot');

  return verbosedStyledTheme;
}
function convertSxToSxVerbosed(sx) {
  if (!sx) return {};
  const sxVerboseTheme = resolveStyledPropsRecursively(sx);
  return sxVerboseTheme;
}
//# sourceMappingURL=convertSxToSxVerbosed.js.map