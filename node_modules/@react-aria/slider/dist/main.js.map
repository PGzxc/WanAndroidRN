{"mappings":"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","sources":["packages/@react-aria/slider/src/index.ts","packages/@react-aria/slider/src/useSlider.ts","packages/@react-aria/slider/src/utils.ts","packages/@react-aria/slider/src/useSliderThumb.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nexport {useSlider} from './useSlider';\nexport {useSliderThumb} from './useSliderThumb';\nexport type {AriaSliderProps} from '@react-types/slider';\nexport type {SliderAria} from './useSlider';\nexport type {AriaSliderThumbOptions, SliderThumbAria} from './useSliderThumb';\nexport type {AriaSliderThumbProps} from '@react-types/slider';\nexport type {Orientation} from '@react-types/shared';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaSliderProps} from '@react-types/slider';\nimport {clamp, mergeProps, useGlobalListeners} from '@react-aria/utils';\nimport {DOMAttributes} from '@react-types/shared';\nimport {getSliderThumbId, sliderData} from './utils';\nimport React, {LabelHTMLAttributes, OutputHTMLAttributes, RefObject, useRef} from 'react';\nimport {setInteractionModality, useMove} from '@react-aria/interactions';\nimport {SliderState} from '@react-stately/slider';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface SliderAria {\n  /** Props for the label element. */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n\n  /** Props for the root element of the slider component; groups slider inputs. */\n  groupProps: DOMAttributes,\n\n  /** Props for the track element. */\n  trackProps: DOMAttributes,\n\n  /** Props for the output element, displaying the value of the slider thumbs. */\n  outputProps: OutputHTMLAttributes<HTMLOutputElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a slider component representing one or more values.\n *\n * @param props Props for the slider.\n * @param state State for the slider, as returned by `useSliderState`.\n * @param trackRef Ref for the \"track\" element.  The width of this element provides the \"length\"\n * of the track -- the span of one dimensional space that the slider thumb can be.  It also\n * accepts click and drag motions, so that the closest thumb will follow clicks and drags on\n * the track.\n */\nexport function useSlider<T extends number | number[]>(\n  props: AriaSliderProps<T>,\n  state: SliderState,\n  trackRef: RefObject<Element>\n): SliderAria {\n  let {labelProps, fieldProps} = useLabel(props);\n\n  let isVertical = props.orientation === 'vertical';\n\n  // Attach id of the label to the state so it can be accessed by useSliderThumb.\n  sliderData.set(state, {\n    id: labelProps.id ?? fieldProps.id,\n    'aria-describedby': props['aria-describedby'],\n    'aria-details': props['aria-details']\n  });\n\n  let {direction} = useLocale();\n\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n  const realTimeTrackDraggingIndex = useRef<number | null>(null);\n\n  const reverseX = direction === 'rtl';\n  const currentPosition = useRef<number>(null);\n  const {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n    },\n    onMove({deltaX, deltaY}) {\n      let {height, width} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = state.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      }\n\n      let delta = isVertical ? deltaY : deltaX;\n      if (isVertical || reverseX) {\n        delta = -delta;\n      }\n\n      currentPosition.current += delta;\n\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        const percent = clamp(currentPosition.current / size, 0, 1);\n        state.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n    onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  });\n\n  let currentPointer = useRef<number | null | undefined>(undefined);\n  let onDownTrack = (e: React.UIEvent, id: number, clientX: number, clientY: number) => {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every((_, i) => !state.isThumbDragging(i))) {\n      let {height, width, top, left} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      // Find the closest thumb\n      const trackPosition = isVertical ? top : left;\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === 'rtl' || isVertical) {\n        percent = 1 - percent;\n      }\n      let value = state.getPercentValue(percent);\n\n      // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n      let closestThumb;\n      let split = state.values.findIndex(v => value - v < 0);\n      if (split === 0) { // If the index is zero then the closetThumb is the first one\n        closestThumb = split;\n      } else if (split === -1) { // If no index is found they've clicked past all the thumbs\n        closestThumb = state.values.length - 1;\n      } else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split];\n        // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) {\n          closestThumb = split - 1;\n        } else {\n          closestThumb = split;\n        }\n      }\n\n      // Confirm that the found closest thumb is editable, not disabled, and move it\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n\n        addGlobalListener(window, 'mouseup', onUpTrack, false);\n        addGlobalListener(window, 'touchend', onUpTrack, false);\n        addGlobalListener(window, 'pointerup', onUpTrack, false);\n      } else {\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  };\n\n  let onUpTrack = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n\n      removeGlobalListener(window, 'mouseup', onUpTrack, false);\n      removeGlobalListener(window, 'touchend', onUpTrack, false);\n      removeGlobalListener(window, 'pointerup', onUpTrack, false);\n    }\n  };\n\n  if ('htmlFor' in labelProps && labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n    labelProps.onClick = () => {\n      // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n      document.getElementById(getSliderThumbId(state, 0))?.focus();\n      setInteractionModality('keyboard');\n    };\n  }\n\n  return {\n    labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: {\n      role: 'group',\n      ...fieldProps\n    },\n    trackProps: mergeProps({\n      onMouseDown(e: React.MouseEvent) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n      onPointerDown(e: React.PointerEvent) {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) {\n          return;\n        }\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n      onTouchStart(e: React.TouchEvent) { onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY); },\n      style: {\n        position: 'relative',\n        touchAction: 'none'\n      }\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map((_, index) => getSliderThumbId(state, index)).join(' '),\n      'aria-live': 'off'\n    }\n  };\n}\n","import {SliderState} from '@react-stately/slider';\n\ninterface SliderData {\n  id: string,\n  'aria-describedby'?: string,\n  'aria-details'?: string\n}\n\nexport const sliderData = new WeakMap<SliderState, SliderData>();\n\nexport function getSliderThumbId(state: SliderState, index: number) {\n  let data = sliderData.get(state);\n  if (!data) {\n    throw new Error('Unknown slider state');\n  }\n\n  return `${data.id}-${index}`;\n}\n","import {AriaSliderThumbProps} from '@react-types/slider';\nimport {clamp, focusWithoutScrolling, mergeProps, useFormReset, useGlobalListeners} from '@react-aria/utils';\nimport {DOMAttributes} from '@react-types/shared';\nimport {getSliderThumbId, sliderData} from './utils';\nimport React, {ChangeEvent, InputHTMLAttributes, LabelHTMLAttributes, RefObject, useCallback, useEffect, useRef} from 'react';\nimport {SliderState} from '@react-stately/slider';\nimport {useFocusable} from '@react-aria/focus';\nimport {useKeyboard, useMove} from '@react-aria/interactions';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface SliderThumbAria {\n  /** Props for the root thumb element; handles the dragging motion. */\n  thumbProps: DOMAttributes,\n\n  /** Props for the visually hidden range input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>,\n\n  /** Props for the label element for this thumb (optional). */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n\n  /** Whether this thumb is currently being dragged. */\n  isDragging: boolean,\n  /** Whether the thumb is currently focused. */\n  isFocused: boolean,\n  /** Whether the thumb is disabled. */\n  isDisabled: boolean\n}\n\nexport interface AriaSliderThumbOptions extends AriaSliderThumbProps {\n  /** A ref to the track element. */\n  trackRef: RefObject<Element>,\n  /** A ref to the thumb input element. */\n  inputRef: RefObject<HTMLInputElement>\n}\n\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\nexport function useSliderThumb(\n  opts: AriaSliderThumbOptions,\n  state: SliderState\n): SliderThumbAria {\n  let {\n    index = 0,\n    isRequired,\n    validationState,\n    isInvalid,\n    trackRef,\n    inputRef,\n    orientation = state.orientation,\n    name\n  } = opts;\n\n  let isDisabled = opts.isDisabled || state.isDisabled;\n  let isVertical = orientation === 'vertical';\n\n  let {direction} = useLocale();\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let data = sliderData.get(state);\n  const {labelProps, fieldProps} = useLabel({\n    ...opts,\n    id: getSliderThumbId(state, index),\n    'aria-labelledby': `${data.id} ${opts['aria-labelledby'] ?? ''}`.trim()\n  });\n\n  const value = state.values[index];\n\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n\n  const isFocused = state.focusedThumb === index;\n\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef<number>(null);\n\n  let {keyboardProps} = useKeyboard({\n    onKeyDown(e) {\n      let {\n        getThumbMaxValue,\n        getThumbMinValue,\n        decrementThumb,\n        incrementThumb,\n        setThumbValue,\n        setThumbDragging,\n        pageSize\n      } = state;\n      // these are the cases that useMove or useSlider don't handle\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      }\n      // same handling as useMove, stopPropagation to prevent useSlider from handling the event as well.\n      e.preventDefault();\n      // remember to set this so that onChangeEnd is fired\n      setThumbDragging(index, true);\n      switch (e.key) {\n        case 'PageUp':\n          incrementThumb(index, pageSize);\n          break;\n        case 'PageDown':\n          decrementThumb(index, pageSize);\n          break;\n        case 'Home':\n          setThumbValue(index, getThumbMinValue(index));\n          break;\n        case 'End':\n          setThumbValue(index, getThumbMaxValue(index));\n          break;\n      }\n      setThumbDragging(index, false);\n    }\n  });\n\n  let {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove({deltaX, deltaY, pointerType, shiftKey}) {\n      const {\n        getThumbPercent,\n        setThumbPercent,\n        decrementThumb,\n        incrementThumb,\n        step,\n        pageSize\n      } = state;\n      let {width, height} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = getThumbPercent(index) * size;\n      }\n      if (pointerType === 'keyboard') {\n        if ((deltaX > 0 && reverseX) || (deltaX < 0 && !reverseX) || deltaY > 0) {\n          decrementThumb(index, shiftKey ? pageSize : step);\n        } else {\n          incrementThumb(index, shiftKey ? pageSize : step);\n        }\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n\n        currentPosition.current += delta;\n        setThumbPercent(index, clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    }\n  });\n\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n\n  const {focusableProps} = useFocusable(\n    mergeProps(opts, {\n      onFocus: () => state.setFocusedThumb(index),\n      onBlur: () => state.setFocusedThumb(undefined)\n    }),\n    inputRef\n  );\n\n  let currentPointer = useRef<number | undefined>(undefined);\n  let onDown = (id?: number) => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n\n  };\n\n  let onUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  let thumbPosition = state.getThumbPercent(index);\n  if (isVertical || direction === 'rtl') {\n    thumbPosition = 1 - thumbPosition;\n  }\n\n  let interactions = !isDisabled ? mergeProps(\n    keyboardProps,\n    moveProps,\n    {\n      onMouseDown: (e: React.MouseEvent) => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDown();\n      },\n      onPointerDown: (e: React.PointerEvent) => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDown(e.pointerId);\n      },\n      onTouchStart: (e: React.TouchEvent) => {onDown(e.changedTouches[0].identifier);}\n    }\n  ) : {};\n\n  useFormReset(inputRef, value, (v) => {\n    state.setThumbValue(index, v);\n  });\n\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      type: 'range',\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      name,\n      disabled: isDisabled,\n      'aria-orientation': orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': isInvalid || validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      'aria-describedby': [data['aria-describedby'], opts['aria-describedby']].filter(Boolean).join(' '),\n      'aria-details': [data['aria-details'], opts['aria-details']].filter(Boolean).join(' '),\n      onChange: (e: ChangeEvent<HTMLInputElement>) => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: {\n      ...interactions,\n      style: {\n        position: 'absolute',\n        [isVertical ? 'top' : 'left']: `${thumbPosition * 100}%`,\n        transform: 'translate(-50%, -50%)',\n        touchAction: 'none'\n      }\n    },\n    labelProps,\n    isDragging: state.isThumbDragging(index),\n    isDisabled,\n    isFocused\n  };\n}\n"],"names":[],"version":3,"file":"main.js.map"}