{"mappings":"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","sources":["packages/@react-aria/selection/src/index.ts","packages/@react-aria/selection/src/useSelectableCollection.ts","packages/@react-aria/selection/src/utils.ts","packages/@react-aria/selection/src/useTypeSelect.ts","packages/@react-aria/selection/src/useSelectableItem.ts","packages/@react-aria/selection/src/useSelectableList.ts","packages/@react-aria/selection/src/ListKeyboardDelegate.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useSelectableCollection} from './useSelectableCollection';\nexport {useSelectableItem} from './useSelectableItem';\nexport {useSelectableList} from './useSelectableList';\nexport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nexport {useTypeSelect} from './useTypeSelect';\n\nexport type {AriaSelectableCollectionOptions, SelectableCollectionAria} from './useSelectableCollection';\nexport type {AriaSelectableListOptions, SelectableListAria} from './useSelectableList';\nexport type {SelectableItemOptions, SelectableItemStates, SelectableItemAria} from './useSelectableItem';\nexport type {AriaTypeSelectOptions, TypeSelectAria} from './useTypeSelect';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, FocusStrategy, KeyboardDelegate} from '@react-types/shared';\nimport {flushSync} from 'react-dom';\nimport {FocusEvent, Key, KeyboardEvent, RefObject, useEffect, useRef} from 'react';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {focusWithoutScrolling, mergeProps, scrollIntoView, scrollIntoViewport, useEvent, useRouter} from '@react-aria/utils';\nimport {getInteractionModality} from '@react-aria/interactions';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useLocale} from '@react-aria/i18n';\nimport {useTypeSelect} from './useTypeSelect';\n\nexport interface AriaSelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean,\n  /**\n   * Whether the collection items are contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections.\n   * If not provided, defaults to the collection ref.\n   */\n  scrollRef?: RefObject<HTMLElement>,\n  /**\n   * The behavior of links in the collection.\n   * - 'action': link behaves like onAction.\n   * - 'selection': link follows selection interactions (e.g. if URL drives selection).\n   * - 'override': links override all other interactions (link items are not selectable).\n   * @default 'action'\n   */\n  linkBehavior?: 'action' | 'selection' | 'override'\n}\n\nexport interface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: DOMAttributes\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: AriaSelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref,\n    linkBehavior = 'action'\n  } = options;\n  let {direction} = useLocale();\n  let router = useRouter();\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') {\n      e.preventDefault();\n    }\n\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target as Element)) {\n      return;\n    }\n\n    const navigateToKey = (key: Key | undefined, childFocus?: FocusStrategy) => {\n      if (key != null) {\n        if (manager.isLink(key) && linkBehavior === 'selection' && selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          // Set focused key and re-render synchronously to bring item into view if needed.\n          flushSync(() => {\n            manager.setFocusedKey(key, childFocus);\n          });\n\n          let item = scrollRef.current.querySelector(`[data-key=\"${key}\"]`);\n          router.open(item, e);\n\n          return;\n        }\n\n        manager.setFocusedKey(key, childFocus);\n\n        if (manager.isLink(key) && linkBehavior === 'override') {\n          return;\n        }\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyBelow(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyAbove(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = direction === 'rtl' ? delegate.getFirstKey?.(manager.focusedKey) : delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = direction === 'rtl' ? delegate.getLastKey?.(manager.focusedKey) : delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n            let next: FocusableElement;\n            let last: FocusableElement;\n            do {\n              last = walker.lastChild() as FocusableElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  // Store the scroll position so we can restore it later.\n  let scrollPos = useRef({top: 0, left: 0});\n  useEvent(scrollRef, 'scroll', isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = (key: Key | undefined) => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) {\n            manager.replaceSelection(key);\n          }\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        navigateToFirstKey(manager.lastSelectedKey ?? delegate.getLastKey());\n      } else {\n        navigateToFirstKey(manager.firstSelectedKey ?? delegate.getFirstKey());\n      }\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n    }\n\n    if (!isVirtualized && manager.focusedKey != null) {\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection, or the collection itself.\n        if (!element.contains(document.activeElement)) {\n          focusWithoutScrolling(element);\n        }\n\n        let modality = getInteractionModality();\n        if (modality === 'keyboard') {\n          scrollIntoViewport(element, {containingElement: ref.current});\n        }\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  const autoFocusRef = useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n    autoFocusRef.current = false;\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  let lastFocusedKey = useRef(manager.focusedKey);\n  useEffect(() => {\n    let modality = getInteractionModality();\n    if (manager.isFocused && manager.focusedKey != null && scrollRef?.current) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element && modality === 'keyboard') {\n        if (!isVirtualized) {\n          scrollIntoView(scrollRef.current, element);\n        }\n        scrollIntoViewport(element, {containingElement: ref.current});\n      }\n    }\n\n    // If the focused key becomes null (e.g. the last item is deleted), focus the whole collection.\n    if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null) {\n      focusSafely(ref.current);\n    }\n\n    lastFocusedKey.current = manager.focusedKey;\n  }, [isVirtualized, scrollRef, manager.focusedKey, manager.isFocused, ref]);\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (scrollRef.current === e.target) {\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {isAppleDevice, isMac} from '@react-aria/utils';\n\ninterface Event {\n  altKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean\n}\n\nexport function isNonContiguousSelectionModifier(e: Event) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return isAppleDevice() ? e.altKey : e.ctrlKey;\n}\n\nexport function isCtrlKeyPressed(e: Event) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, KeyboardDelegate} from '@react-types/shared';\nimport {Key, KeyboardEvent, useRef} from 'react';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\n/**\n * Controls how long to wait before clearing the typeahead buffer.\n */\nconst TYPEAHEAD_DEBOUNCE_WAIT_MS = 1000; // 1 second\n\nexport interface AriaTypeSelectOptions {\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * Called when an item is focused by typing.\n   */\n  onTypeSelect?: (key: Key) => void\n}\n\nexport interface TypeSelectAria {\n  /**\n   * Props to be spread on the owner of the options.\n   */\n  typeSelectProps: DOMAttributes\n}\n\n/**\n * Handles typeahead interactions with collections.\n */\nexport function useTypeSelect(options: AriaTypeSelectOptions): TypeSelectAria {\n  let {keyboardDelegate, selectionManager, onTypeSelect} = options;\n  let state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    let character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey || !e.currentTarget.contains(e.target as HTMLElement)) {\n      return;\n    }\n\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n\n    state.search += character;\n\n    // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n    // If no key found, search from the top.\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, TYPEAHEAD_DEBOUNCE_WAIT_MS);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction getStringForKey(key: string) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, LongPressEvent, PressEvent} from '@react-types/shared';\nimport {focusSafely} from '@react-aria/focus';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {Key, RefObject, useEffect, useRef} from 'react';\nimport {mergeProps, openLink, useRouter} from '@react-aria/utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {PressProps, useLongPress, usePress} from '@react-aria/interactions';\n\nexport interface SelectableItemOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A unique key for the item.\n   */\n  key: Key,\n  /**\n   * Ref to the item.\n   */\n  ref: RefObject<FocusableElement>,\n  /**\n   * By default, selection occurs on pointer down. This can be strange if selecting an\n   * item causes the UI to disappear immediately (e.g. menus).\n   */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Whether selection requires the pointer/mouse down and up events to occur on the same target or triggers selection on\n   * the target of the pointer/mouse up event.\n   */\n  allowsDifferentPressOrigin?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Function to focus the item.\n   */\n  focus?: () => void,\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /** Whether the item is disabled. */\n  isDisabled?: boolean,\n  /**\n   * Handler that is called when a user performs an action on the item. The exact user event depends on\n   * the collection's `selectionBehavior` prop and the interaction modality.\n   */\n  onAction?: () => void,\n  /**\n   * The behavior of links in the collection.\n   * - 'action': link behaves like onAction.\n   * - 'selection': link follows selection interactions (e.g. if URL drives selection).\n   * - 'override': links override all other interactions (link items are not selectable).\n   * - 'none': links are disabled for both selection and actions (e.g. handled elsewhere).\n   * @default 'action'\n   */\n  linkBehavior?: 'action' | 'selection' | 'override' | 'none'\n}\n\nexport interface SelectableItemStates {\n  /** Whether the item is currently in a pressed state. */\n  isPressed: boolean,\n  /** Whether the item is currently selected. */\n  isSelected: boolean,\n  /** Whether the item is currently focused. */\n  isFocused: boolean,\n  /**\n   * Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may\n   * not be focused. Dependent on `disabledKeys` and `disabledBehavior`.\n   */\n  isDisabled: boolean,\n  /**\n   * Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`.\n   */\n  allowsSelection: boolean,\n  /**\n   * Whether the item has an action, dependent on `onAction`, `disabledKeys`,\n   * and `disabledBehavior`. It may also change depending on the current selection state\n   * of the list (e.g. when selection is primary). This can be used to enable or disable hover\n   * styles or other visual indications of interactivity.\n   */\n  hasAction: boolean\n}\n\nexport interface SelectableItemAria extends SelectableItemStates {\n  /**\n   * Props to be spread on the item root node.\n   */\n  itemProps: DOMAttributes\n}\n\n/**\n * Handles interactions with an item in a selectable collection.\n */\nexport function useSelectableItem(options: SelectableItemOptions): SelectableItemAria {\n  let {\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    shouldUseVirtualFocus,\n    focus,\n    isDisabled,\n    onAction,\n    allowsDifferentPressOrigin,\n    linkBehavior = 'action'\n  } = options;\n  let router = useRouter();\n\n  let onSelect = (e: PressEvent | LongPressEvent | PointerEvent) => {\n    if (e.pointerType === 'keyboard' && isNonContiguousSelectionModifier(e)) {\n      manager.toggleSelection(key);\n    } else {\n      if (manager.selectionMode === 'none') {\n        return;\n      }\n\n      if (manager.isLink(key)) {\n        if (linkBehavior === 'selection') {\n          router.open(ref.current, e);\n          // Always set selected keys back to what they were so that select and combobox close.\n          manager.setSelectedKeys(manager.selectedKeys);\n          return;\n        } else if (linkBehavior === 'override' || linkBehavior === 'none') {\n          return;\n        }\n      }\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) {\n          manager.toggleSelection(key);\n        } else {\n          manager.replaceSelection(key);\n        }\n      } else if (e && e.shiftKey) {\n        manager.extendSelection(key);\n      } else if (manager.selectionBehavior === 'toggle' || (e && (isCtrlKeyPressed(e) || e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);\n      } else {\n        manager.replaceSelection(key);\n      }\n    }\n  };\n\n  // Focus the associated DOM node when this item becomes the focusedKey\n  useEffect(() => {\n    let isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus) {\n      if (focus) {\n        focus();\n      } else if (document.activeElement !== ref.current) {\n        focusSafely(ref.current);\n      }\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n\n  isDisabled = isDisabled || manager.isDisabled(key);\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps: SelectableItemAria['itemProps'] = {};\n  if (!shouldUseVirtualFocus && !isDisabled) {\n    itemProps = {\n      tabIndex: key === manager.focusedKey ? 0 : -1,\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  } else if (isDisabled) {\n    itemProps.onMouseDown = (e) => {\n      // Prevent focus going to the body when clicking on a disabled item.\n      e.preventDefault();\n    };\n  }\n\n  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n  let isLinkOverride = manager.isLink(key) && linkBehavior === 'override';\n  let hasLinkAction = manager.isLink(key) && linkBehavior !== 'selection' && linkBehavior !== 'none';\n  let allowsSelection = !isDisabled && manager.canSelectItem(key) && !isLinkOverride;\n  let allowsActions = (onAction || hasLinkAction) && !isDisabled;\n  let hasPrimaryAction = allowsActions && (\n    manager.selectionBehavior === 'replace'\n      ? !allowsSelection\n      : !allowsSelection || manager.isEmpty\n  );\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === 'replace';\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = useRef(null);\n\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = useRef(false);\n  let hadPrimaryActionOnPressStart = useRef(false);\n\n  let performAction = (e) => {\n    if (onAction) {\n      onAction();\n    }\n\n    if (hasLinkAction) {\n      router.open(ref.current, e);\n    }\n  };\n\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps: PressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === 'keyboard' && (!hasAction || isSelectionKey())) {\n        onSelect(e);\n      }\n    };\n\n    // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n    if (!allowsDifferentPressOrigin) {\n      itemPressProps.onPress = (e) => {\n        if (hasPrimaryAction || (hasSecondaryAction && e.pointerType !== 'mouse')) {\n          if (e.pointerType === 'keyboard' && !isActionKey()) {\n            return;\n          }\n\n          performAction(e);\n        } else if (e.pointerType !== 'keyboard' && allowsSelection) {\n          onSelect(e);\n        }\n      };\n    } else {\n      itemPressProps.onPressUp = hasPrimaryAction ? null : (e) => {\n        if (e.pointerType !== 'keyboard' && allowsSelection) {\n          onSelect(e);\n        }\n      };\n\n      itemPressProps.onPress = hasPrimaryAction ? performAction : null;\n    }\n  } else {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n\n      // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n      if (\n        allowsSelection && (\n          (e.pointerType === 'mouse' && !hasPrimaryAction) ||\n          (e.pointerType === 'keyboard' && (!allowsActions || isSelectionKey()))\n        )\n      ) {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = (e) => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (\n        e.pointerType === 'touch' ||\n        e.pointerType === 'pen' ||\n        e.pointerType === 'virtual' ||\n        (e.pointerType === 'keyboard' && hasAction && isActionKey()) ||\n        (e.pointerType === 'mouse' && hadPrimaryActionOnPressStart.current)\n      ) {\n        if (hasAction) {\n          performAction(e);\n        } else if (allowsSelection) {\n          onSelect(e);\n        }\n      }\n    };\n  }\n\n  itemProps['data-key'] = key;\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {pressProps, isPressed} = usePress(itemPressProps);\n\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? (e) => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      performAction(e);\n    }\n  } : undefined;\n\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  let {longPressProps} = useLongPress({\n    isDisabled: !longPressEnabled,\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  });\n\n  // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  // Use a capturing listener to ensure this runs before useDrag, regardless of\n  // the order the props get merged.\n  let onDragStartCapture = e => {\n    if (modality.current === 'touch' && longPressEnabledOnPressStart.current) {\n      e.preventDefault();\n    }\n  };\n\n  // Prevent default on link clicks so that we control exactly\n  // when they open (to match selection behavior).\n  let onClick = manager.isLink(key) ? e => {\n    if (!openLink.isOpening) {\n      e.preventDefault();\n    }\n  } : undefined;\n\n  return {\n    itemProps: mergeProps(\n      itemProps,\n      allowsSelection || hasPrimaryAction ? pressProps : {},\n      longPressEnabled ? longPressProps : {},\n      {onDoubleClick, onDragStartCapture, onClick}\n    ),\n    isPressed,\n    isSelected: manager.isSelected(key),\n    isFocused: manager.isFocused && manager.focusedKey === key,\n    isDisabled,\n    allowsSelection,\n    hasAction\n  };\n}\n\nfunction isActionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === 'Enter';\n}\n\nfunction isSelectionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === ' ' || event?.code === 'Space';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaSelectableCollectionOptions, useSelectableCollection} from './useSelectableCollection';\nimport {Collection, DOMAttributes, KeyboardDelegate, Node} from '@react-types/shared';\nimport {Key, useMemo} from 'react';\nimport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nimport {useCollator} from '@react-aria/i18n';\n\nexport interface AriaSelectableListOptions extends Omit<AriaSelectableCollectionOptions, 'keyboardDelegate'> {\n  /**\n   * State of the collection.\n   */\n  collection: Collection<Node<unknown>>,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate?: KeyboardDelegate,\n  /**\n   * The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\n   */\n  disabledKeys: Set<Key>\n}\n\nexport interface SelectableListAria {\n  /**\n   * Props for the option element.\n   */\n  listProps: DOMAttributes\n}\n\n/**\n * Handles interactions with a selectable list.\n */\nexport function useSelectableList(props: AriaSelectableListOptions): SelectableListAria {\n  let {\n    selectionManager,\n    collection,\n    disabledKeys,\n    ref,\n    keyboardDelegate\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({usage: 'search', sensitivity: 'base'});\n  let disabledBehavior = selectionManager.disabledBehavior;\n  let delegate = useMemo(() => (\n    keyboardDelegate || new ListKeyboardDelegate(collection, disabledBehavior === 'selection' ? new Set() : disabledKeys, ref, collator)\n  ), [keyboardDelegate, collection, disabledKeys, ref, collator, disabledBehavior]);\n\n  let {collectionProps} = useSelectableCollection({\n    ...props,\n    ref,\n    selectionManager,\n    keyboardDelegate: delegate\n  });\n\n  return {\n    listProps: collectionProps\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Direction, KeyboardDelegate, Node, Orientation} from '@react-types/shared';\nimport {isScrollable} from '@react-aria/utils';\nimport {Key, RefObject} from 'react';\n\ninterface ListKeyboardDelegateOptions<T> {\n  collection: Collection<Node<T>>,\n  ref: RefObject<HTMLElement>,\n  collator?: Intl.Collator,\n  layout?: 'stack' | 'grid',\n  orientation?: Orientation,\n  direction?: Direction,\n  disabledKeys?: Set<Key>\n}\n\nexport class ListKeyboardDelegate<T> implements KeyboardDelegate {\n  private collection: Collection<Node<T>>;\n  private disabledKeys: Set<Key>;\n  private ref: RefObject<HTMLElement>;\n  private collator: Intl.Collator | undefined;\n  private layout: 'stack' | 'grid';\n  private orientation?: Orientation;\n  private direction?: Direction;\n\n  constructor(collection: Collection<Node<T>>, disabledKeys: Set<Key>, ref: RefObject<HTMLElement>, collator?: Intl.Collator);\n  constructor(options: ListKeyboardDelegateOptions<T>);\n  constructor(...args: any[]) {\n    if (args.length === 1) {\n      let opts = args[0] as ListKeyboardDelegateOptions<T>;\n      this.collection = opts.collection;\n      this.ref = opts.ref;\n      this.collator = opts.collator;\n      this.disabledKeys = opts.disabledKeys || new Set();\n      this.orientation = opts.orientation;\n      this.direction = opts.direction;\n      this.layout = opts.layout || 'stack';\n    } else {\n      this.collection = args[0];\n      this.disabledKeys = args[1];\n      this.ref = args[2];\n      this.collator = args[3];\n      this.layout = 'stack';\n      this.orientation = 'vertical';\n    }\n\n    // If this is a vertical stack, remove the left/right methods completely\n    // so they aren't called by useDroppableCollection.\n    if (this.layout === 'stack' && this.orientation === 'vertical') {\n      this.getKeyLeftOf = undefined;\n      this.getKeyRightOf = undefined;\n    }\n  }\n\n  getNextKey(key: Key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return null;\n  }\n\n  getPreviousKey(key: Key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n\n    return null;\n  }\n\n  private findKey(\n    key: Key,\n    nextKey: (key: Key) => Key,\n    shouldSkip: (prevRect: DOMRect, itemRect: DOMRect) => boolean\n  ) {\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    // Find the item above or below in the same column.\n    let prevRect = item.getBoundingClientRect();\n    do {\n      key = nextKey(key);\n      item = this.getItem(key);\n    } while (item && shouldSkip(prevRect, item.getBoundingClientRect()));\n\n    return key;\n  }\n\n  private isSameRow(prevRect: DOMRect, itemRect: DOMRect) {\n    return prevRect.top === itemRect.top || prevRect.left !== itemRect.left;\n  }\n\n  private isSameColumn(prevRect: DOMRect, itemRect: DOMRect) {\n    return prevRect.left === itemRect.left || prevRect.top !== itemRect.top;\n  }\n\n  getKeyBelow(key: Key) {\n    if (this.layout === 'grid' && this.orientation === 'vertical') {\n      return this.findKey(key, (key) => this.getNextKey(key), this.isSameRow);\n    } else {\n      return this.getNextKey(key);\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    if (this.layout === 'grid' && this.orientation === 'vertical') {\n      return this.findKey(key, (key) => this.getPreviousKey(key), this.isSameRow);\n    } else {\n      return this.getPreviousKey(key);\n    }\n  }\n\n  private getNextColumn(key: Key, right: boolean) {\n    return right ? this.getPreviousKey(key) : this.getNextKey(key);\n  }\n\n  getKeyRightOf(key: Key) {\n    if (this.layout === 'grid') {\n      if (this.orientation === 'vertical') {\n        return this.getNextColumn(key, this.direction === 'rtl');\n      } else {\n        return this.findKey(key, (key) => this.getNextColumn(key, this.direction === 'rtl'), this.isSameColumn);\n      }\n    } else if (this.orientation === 'horizontal') {\n      return this.getNextColumn(key, this.direction === 'rtl');\n    }\n\n    return null;\n  }\n\n  getKeyLeftOf(key: Key) {\n    if (this.layout === 'grid') {\n      if (this.orientation === 'vertical') {\n        return this.getNextColumn(key, this.direction === 'ltr');\n      } else {\n        return this.findKey(key, (key) => this.getNextColumn(key, this.direction === 'ltr'), this.isSameColumn);\n      }\n    } else if (this.orientation === 'horizontal') {\n      return this.getNextColumn(key, this.direction === 'ltr');\n    }\n\n    return null;\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return null;\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n\n    return null;\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n\n  getKeyPageAbove(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    if (!isScrollable(menu)) {\n      return this.getFirstKey();\n    }\n\n    let containerRect = menu.getBoundingClientRect();\n    let itemRect = item.getBoundingClientRect();\n    if (this.orientation === 'horizontal') {\n      let containerX = containerRect.x - menu.scrollLeft;\n      let pageX = Math.max(0, (itemRect.x - containerX) + itemRect.width - containerRect.width);\n\n      while (item && (itemRect.x - containerX) > pageX) {\n        key = this.getKeyAbove(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item?.getBoundingClientRect();\n      }\n    } else {\n      let containerY = containerRect.y - menu.scrollTop;\n      let pageY = Math.max(0, (itemRect.y - containerY) + itemRect.height - containerRect.height);\n\n      while (item && (itemRect.y - containerY) > pageY) {\n        key = this.getKeyAbove(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item?.getBoundingClientRect();\n      }\n    }\n\n    return key ?? this.getFirstKey();\n  }\n\n  getKeyPageBelow(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    if (!isScrollable(menu)) {\n      return this.getLastKey();\n    }\n\n    let containerRect = menu.getBoundingClientRect();\n    let itemRect = item.getBoundingClientRect();\n    if (this.orientation === 'horizontal') {\n      let containerX = containerRect.x - menu.scrollLeft;\n      let pageX = Math.min(menu.scrollWidth, (itemRect.x - containerX) - itemRect.width + containerRect.width);\n\n      while (item && (itemRect.x - containerX) < pageX) {\n        key = this.getKeyBelow(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item?.getBoundingClientRect();\n      }\n    } else {\n      let containerY = containerRect.y - menu.scrollTop;\n      let pageY = Math.min(menu.scrollHeight, (itemRect.y - containerY) - itemRect.height + containerRect.height);\n\n      while (item && (itemRect.y - containerY) < pageY) {\n        key = this.getKeyBelow(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item?.getBoundingClientRect();\n      }\n    }\n\n    return key ?? this.getLastKey();\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n}\n"],"names":[],"version":3,"file":"main.js.map"}