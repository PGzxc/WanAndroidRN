{"version":3,"sources":["useSlider.ts"],"names":["sliderIds","useRef","useLabel","isRTL","useSlider","props","state","trackLayout","isReversed","labelProps","fieldProps","isVertical","orientation","set","id","currentPointer","undefined","onDownTrack","e","clientX","clientY","direction","reverseX","isDisabled","values","every","_","i","isThumbDragging","size","height","width","trackPosition","clickPosition","offset","percent","value","getPercentValue","closestThumb","split","findIndex","v","length","lastLeft","firstRight","Math","abs","isThumbEditable","preventDefault","setFocusedThumb","current","setThumbDragging","setThumbValue","groupProps","trackProps","onPress","locationX","locationY","nativeEvent","outputProps"],"mappings":"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","sourcesContent":["import { sliderIds } from './utils';\nimport { AriaSliderProps } from '@react-types/slider';\nimport React, { useRef } from 'react';\nimport { SliderState } from '@react-stately/slider';\nimport { useLabel } from '@react-aria/label';\nimport { isRTL } from '@react-native-aria/utils';\n\ninterface SliderAria {\n  /** Props for the label element. */\n  labelProps: any;\n\n  /** Props for the root element of the slider component; groups slider inputs. */\n  groupProps: any;\n\n  /** Props for the track element. */\n  trackProps: any;\n\n  /** Props for the output element, displaying the value of the slider thumbs. */\n  outputProps: any;\n}\n\n/**\n * Provides the behavior and accessibility implementation for a slider component representing one or more values.\n *\n * @param props Props for the slider.\n * @param state State for the slider, as returned by `useSliderState`.\n * @param trackRef Ref for the \"track\" element.  The width of this element provides the \"length\"\n * of the track -- the span of one dimensional space that the slider thumb can be.  It also\n * accepts click and drag motions, so that the closest thumb will follow clicks and drags on\n * the track.\n */\nexport function useSlider(\n  props: AriaSliderProps,\n  state: SliderState,\n  trackLayout: any,\n  isReversed?: boolean\n): SliderAria {\n  let { labelProps, fieldProps } = useLabel(props);\n\n  let isVertical = props.orientation === 'vertical';\n\n  sliderIds.set(state, labelProps.id ?? fieldProps.id);\n  let currentPointer = useRef<number | null | undefined>(undefined);\n\n  let onDownTrack = (\n    e: React.UIEvent,\n    id: number,\n    clientX: number,\n    clientY: number\n  ) => {\n    const direction = isRTL() ? 'rtl' : undefined;\n    const reverseX = isReversed || direction === 'rtl';\n    if (\n      !props.isDisabled &&\n      state.values.every((_, i) => !state.isThumbDragging(i))\n    ) {\n      let size = isVertical ? trackLayout.height : trackLayout.width;\n      // Find the closest thumb\n      const trackPosition = trackLayout[isVertical ? 'y' : 'x'];\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (reverseX) {\n        if (!isVertical) {\n          percent = 1 - percent;\n        }\n      } else {\n        if (isVertical) {\n          percent = 1 - percent;\n        }\n      }\n      let value = state.getPercentValue(percent);\n      // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n      let closestThumb;\n      let split = state.values.findIndex((v) => value - v < 0);\n      if (split === 0) {\n        // If the index is zero then the closetThumb is the first one\n        closestThumb = split;\n      } else if (split === -1) {\n        // If no index is found they've clicked past all the thumbs\n        closestThumb = state.values.length - 1;\n      } else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split];\n        // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) {\n          closestThumb = split - 1;\n        } else {\n          closestThumb = split;\n        }\n      }\n      // Confirm that the found closest thumb is editable, not disabled, and move it\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n        state.setThumbDragging(closestThumb, true);\n        state.setThumbValue(closestThumb, value);\n        state.setThumbDragging(closestThumb, false);\n      }\n    }\n  };\n\n  return {\n    labelProps,\n    groupProps: {},\n    trackProps: {\n      onPress: (e: any) => {\n        const { locationX, locationY } = e.nativeEvent;\n        onDownTrack(e, undefined, locationX, locationY);\n      },\n    },\n    outputProps: {},\n  };\n}\n"]}