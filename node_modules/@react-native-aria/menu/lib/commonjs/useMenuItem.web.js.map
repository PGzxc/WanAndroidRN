{"version":3,"sources":["useMenuItem.web.ts"],"names":["useMenuItem","props","state","ref","isSelected","isDisabled","key","onClose","closeOnSelect","isVirtualized","onAction","role","selectionManager","selectionMode","labelId","descriptionId","keyboardId","ariaProps","filter","Boolean","join","undefined","collection","getItem","index","onPressStart","e","pointerType","onPressUp","itemProps","shouldSelectOnPressUp","pressProps","hoverProps","onHoverStart","setFocused","setFocusedKey","keyboardProps","onKeyDown","repeat","continuePropagation","menuItemProps","accessibilityRole","labelProps","nativeID","descriptionProps","keyboardShortcutProps"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { getItemCount } from '@react-stately/collections';\nimport { Key, RefObject } from 'react';\nimport { isFocusVisible, useKeyboard } from '@react-aria/interactions';\nimport { useHover, usePress } from '@react-native-aria/interactions';\nimport { mapDomPropsToRN } from '@react-native-aria/utils';\nimport { mergeProps, useSlotId } from '@react-aria/utils';\nimport { PressEvent } from '@react-types/shared';\nimport { TreeState } from '@react-stately/tree';\nimport { useSelectableItem } from '@react-aria/selection';\nimport { ViewProps } from 'react-native';\ninterface MenuItemAria {\n  /** Props for the menu item element. */\n  menuItemProps: ViewProps;\n\n  /** Props for the main text element inside the menu item. */\n  labelProps: ViewProps;\n\n  /** Props for the description text element inside the menu item, if any. */\n  descriptionProps: ViewProps;\n\n  /** Props for the keyboard shortcut text element inside the item, if any. */\n  keyboardShortcutProps: ViewProps;\n}\n\ninterface AriaMenuItemProps {\n  /** Whether the menu item is disabled. */\n  'isDisabled'?: boolean;\n\n  /** Whether the menu item is selected. */\n  'isSelected'?: boolean;\n\n  /** A screen reader only label for the menu item. */\n  'aria-label'?: string;\n\n  /** The unique key for the menu item. */\n  'key'?: any;\n\n  /** Handler that is called when the menu should close after selecting an item. */\n  'onClose'?: () => void;\n\n  /**\n   * Whether the menu should close when the menu item is selected.\n   * @default true\n   */\n  'closeOnSelect'?: boolean;\n\n  /** Whether the menu item is contained in a virtual scrolling menu. */\n  'isVirtualized'?: boolean;\n\n  /** Handler that is called when the user activates the item. */\n  'onAction'?: (key: Key) => void;\n}\n\n/**\n * Provides the behavior and accessibility implementation for an item in a menu.\n * See `useMenu` for more details about menus.\n * @param props - Props for the item.\n * @param state - State for the menu, as returned by `useTreeState`.\n */\nexport function useMenuItem<T>(\n  props: AriaMenuItemProps,\n  state: TreeState<T>,\n  ref: RefObject<HTMLElement>\n): MenuItemAria {\n  let {\n    isSelected,\n    isDisabled,\n    key,\n    onClose,\n    closeOnSelect = true,\n    isVirtualized,\n    onAction,\n  } = props;\n\n  let role = 'menuitem';\n  if (state.selectionManager.selectionMode === 'single') {\n    role = 'menuitemradio';\n  } else if (state.selectionManager.selectionMode === 'multiple') {\n    role = 'menuitemcheckbox';\n  }\n\n  let labelId = useSlotId();\n  let descriptionId = useSlotId();\n  let keyboardId = useSlotId();\n\n  let ariaProps: any = {\n    'aria-disabled': isDisabled,\n    role,\n    'aria-label': props['aria-label'],\n    'aria-labelledby': labelId,\n    'aria-describedby':\n      [descriptionId, keyboardId].filter(Boolean).join(' ') || undefined,\n  };\n  if (state.selectionManager.selectionMode !== 'none') {\n    ariaProps['aria-checked'] = isSelected;\n  }\n\n  if (isVirtualized) {\n    ariaProps['aria-posinset'] = state.collection.getItem(key).index;\n    ariaProps['aria-setsize'] = getItemCount(state.collection);\n  }\n\n  let onPressStart = (e: PressEvent) => {\n    if (e.pointerType === 'keyboard' && onAction) {\n      onAction(key);\n    }\n  };\n\n  let onPressUp = (e: PressEvent) => {\n    if (e.pointerType !== 'keyboard') {\n      if (onAction) {\n        onAction(key);\n      }\n\n      if (closeOnSelect && onClose) {\n        onClose();\n      }\n    }\n  };\n\n  let { itemProps } = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key,\n    ref,\n    shouldSelectOnPressUp: true,\n  });\n\n  let { pressProps } = usePress(\n    mergeProps(\n      { onPressStart, onPressUp, isDisabled },\n      mapDomPropsToRN(itemProps)\n    )\n  );\n\n  let { hoverProps } = useHover(\n    {\n      isDisabled,\n      onHoverStart() {\n        if (!isFocusVisible()) {\n          state.selectionManager.setFocused(true);\n          state.selectionManager.setFocusedKey(key);\n        }\n      },\n    },\n    ref\n  );\n\n  const { keyboardProps } = useKeyboard({\n    onKeyDown: (e) => {\n      // Ignore repeating events, which may have started on the menu trigger before moving\n      // focus to the menu item. We want to wait for a second complete key press sequence.\n      if (e.repeat) {\n        e.continuePropagation();\n        return;\n      }\n      switch (e.key) {\n        case ' ':\n          if (\n            !isDisabled &&\n            state.selectionManager.selectionMode === 'none' &&\n            closeOnSelect !== false &&\n            onClose\n          ) {\n            onClose();\n          }\n          break;\n        case 'Enter':\n          // The Enter key should always close on select, except if overridden.\n          if (!isDisabled && closeOnSelect !== false && onClose) {\n            onClose();\n          }\n          break;\n        default:\n          e.continuePropagation();\n          break;\n      }\n    },\n  });\n\n  return {\n    menuItemProps: {\n      ...mapDomPropsToRN(ariaProps),\n      ...mergeProps(pressProps, hoverProps, keyboardProps),\n      accessibilityRole: 'button',\n    },\n    labelProps: {\n      nativeID: labelId,\n    },\n    descriptionProps: {\n      nativeID: descriptionId,\n    },\n    keyboardShortcutProps: {\n      nativeID: keyboardId,\n    },\n  };\n}\n"]}