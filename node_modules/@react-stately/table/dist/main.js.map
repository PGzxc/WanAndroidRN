{"mappings":"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","sources":["packages/@react-stately/table/src/index.ts","packages/@react-stately/table/src/useTableColumnResizeState.ts","packages/@react-stately/table/src/TableColumnLayout.ts","packages/@react-stately/table/src/TableUtils.ts","packages/@react-stately/table/src/useTableState.ts","packages/@react-stately/table/src/TableCollection.ts","packages/@react-stately/table/src/TableHeader.ts","packages/@react-stately/table/src/TableBody.ts","packages/@react-stately/table/src/Column.ts","packages/@react-stately/table/src/Row.ts","packages/@react-stately/table/src/Cell.ts","packages/@react-stately/table/src/useTreeGridState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {TableColumnResizeState, TableColumnResizeStateProps} from './useTableColumnResizeState';\nexport type {TableState, CollectionBuilderContext, TableStateProps} from './useTableState';\nexport type {TableHeaderProps, TableBodyProps, ColumnProps, RowProps, CellProps} from '@react-types/table';\nexport type {TreeGridState, TreeGridStateProps} from './useTreeGridState';\n\nexport {useTableColumnResizeState} from './useTableColumnResizeState';\nexport {useTableState} from './useTableState';\nexport {TableHeader} from './TableHeader';\nexport {TableBody} from './TableBody';\nexport {Column} from './Column';\nexport {Row} from './Row';\nexport {Cell} from './Cell';\nexport {Section} from '@react-stately/collections';\nexport {TableCollection, buildHeaderRows} from './TableCollection';\nexport {TableColumnLayout} from './TableColumnLayout';\nexport {UNSTABLE_useTreeGridState} from './useTreeGridState';\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ColumnSize} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {Key, useCallback, useMemo, useState} from 'react';\nimport {TableColumnLayout} from './TableColumnLayout';\nimport {TableState} from './useTableState';\n\nexport interface TableColumnResizeStateProps<T> {\n  /**\n   * Current width of the table or table viewport that the columns\n   * should be calculated against.\n   */\n  tableWidth: number,\n  /** A function that is called to find the default width for a given column. */\n  getDefaultWidth?: (node: GridNode<T>) => ColumnSize | null | undefined,\n  /** A function that is called to find the default minWidth for a given column. */\n  getDefaultMinWidth?: (node: GridNode<T>) => ColumnSize | null | undefined\n}\nexport interface TableColumnResizeState<T> {\n  /**\n   * Called to update the state that a resize event has occurred.\n   * Returns the new widths for all columns based on the resized column.\n   */\n  updateResizedColumns: (key: Key, width: number) => Map<Key, ColumnSize>,\n  /** Callback for when onColumnResize has started. */\n  startResize: (key: Key) => void,\n  /** Callback for when onColumnResize has ended. */\n  endResize: () => void,\n  /** Gets the current width for the specified column. */\n  getColumnWidth: (key: Key) => number,\n  /** Gets the current minWidth for the specified column. */\n  getColumnMinWidth: (key: Key) => number,\n  /** Gets the current maxWidth for the specified column. */\n  getColumnMaxWidth: (key: Key) => number,\n  /** Key of the currently resizing column. */\n  resizingColumn: Key | null,\n  /** A reference to the table state. */\n  tableState: TableState<T>\n}\n\n/**\n * Provides column width state management for a table component with column resizing support. Handles building\n * a map of column widths calculated from the table's width and any provided column width information from the collection.\n * In addition, it tracks the currently resizing column and provides callbacks for updating the widths upon resize operations.\n * @param props - Props for the table.\n * @param state - State for the table, as returned by `useTableState`.\n */\nexport function useTableColumnResizeState<T>(props: TableColumnResizeStateProps<T>, state: TableState<T>): TableColumnResizeState<T> {\n  let {\n    getDefaultWidth,\n    getDefaultMinWidth,\n    tableWidth = 0\n  } = props;\n\n  let [resizingColumn, setResizingColumn] = useState<Key | null>(null);\n  let columnLayout = useMemo(\n    () => new TableColumnLayout({\n      getDefaultWidth,\n      getDefaultMinWidth\n    }),\n    [getDefaultWidth, getDefaultMinWidth]\n  );\n\n  let [controlledColumns, uncontrolledColumns] = useMemo(() =>\n      columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns)\n  , [state.collection.columns, columnLayout]);\n\n  // uncontrolled column widths\n  let [uncontrolledWidths, setUncontrolledWidths] = useState(() =>\n    columnLayout.getInitialUncontrolledWidths(uncontrolledColumns)\n  );\n  // combine columns back into one map that maintains same order as the columns\n  let colWidths = useMemo(() =>\n      columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns)\n  , [state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns, columnLayout]);\n\n  let startResize = useCallback((key: Key) => {\n    setResizingColumn(key);\n  }, [setResizingColumn]);\n\n  let updateResizedColumns = useCallback((key: Key, width: number): Map<Key, ColumnSize> => {\n    let newControlled = new Map(Array.from(controlledColumns).map(([key, entry]) => [key, entry.props.width]));\n    let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n\n    let map = new Map(Array.from(uncontrolledColumns).map(([key]) => [key, newSizes.get(key)]));\n    map.set(key, width);\n    setUncontrolledWidths(map);\n    return newSizes;\n  }, [controlledColumns, uncontrolledColumns, setUncontrolledWidths, tableWidth, columnLayout, state.collection, uncontrolledWidths]);\n\n  let endResize = useCallback(() => {\n    setResizingColumn(null);\n  }, [setResizingColumn]);\n\n  useMemo(() =>\n    columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths)\n  , [tableWidth, state.collection, colWidths, columnLayout]);\n\n  return useMemo(() => ({\n    resizingColumn,\n    updateResizedColumns,\n    startResize,\n    endResize,\n    getColumnWidth: (key: Key) =>\n      columnLayout.getColumnWidth(key),\n    getColumnMinWidth: (key: Key) =>\n      columnLayout.getColumnMinWidth(key),\n    getColumnMaxWidth: (key: Key) =>\n      columnLayout.getColumnMaxWidth(key),\n    tableState: state\n  }), [\n    columnLayout,\n    resizingColumn,\n    updateResizedColumns,\n    startResize,\n    endResize,\n    state\n  ]);\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  calculateColumnSizes,\n  getMaxWidth,\n  getMinWidth,\n  isStatic,\n  parseFractionalUnit\n} from './TableUtils';\nimport {ColumnSize, TableCollection} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from 'react';\n\nexport interface TableColumnLayoutOptions<T> {\n  getDefaultWidth?: (column: GridNode<T>) => ColumnSize | null | undefined,\n  getDefaultMinWidth?: (column: GridNode<T>) => ColumnSize | null | undefined\n}\n\nexport class TableColumnLayout<T> {\n  getDefaultWidth: (column: GridNode<T>) => ColumnSize | null | undefined;\n  getDefaultMinWidth: (column: GridNode<T>) => ColumnSize | null | undefined;\n  columnWidths: Map<Key, number> = new Map();\n  columnMinWidths: Map<Key, number> = new Map();\n  columnMaxWidths: Map<Key, number> = new Map();\n\n  constructor(options: TableColumnLayoutOptions<T>) {\n    this.getDefaultWidth = options?.getDefaultWidth ?? (() => '1fr');\n    this.getDefaultMinWidth = options?.getDefaultMinWidth ?? (() => 75);\n  }\n\n  /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */\n  splitColumnsIntoControlledAndUncontrolled(columns: Array<GridNode<T>>): [Map<Key, GridNode<T>>, Map<Key, GridNode<T>>] {\n    return columns.reduce((acc, col) => {\n      if (col.props.width != null) {\n        acc[0].set(col.key, col);\n      } else {\n        acc[1].set(col.key, col);\n      }\n      return acc;\n    }, [new Map(), new Map()]);\n  }\n\n  /** Takes uncontrolled and controlled widths and joins them into a single Map. */\n  recombineColumns(columns: Array<GridNode<T>>, uncontrolledWidths: Map<Key, ColumnSize>, uncontrolledColumns: Map<Key, GridNode<T>>, controlledColumns: Map<Key, GridNode<T>>): Map<Key, ColumnSize> {\n    return new Map(columns.map(col => {\n      if (uncontrolledColumns.has(col.key)) {\n        return [col.key, uncontrolledWidths.get(col.key)];\n      } else {\n        return [col.key, controlledColumns.get(col.key).props.width];\n      }\n    }));\n  }\n\n  /** Used to make an initial Map of the uncontrolled widths based on default widths. */\n  getInitialUncontrolledWidths(uncontrolledColumns: Map<Key, GridNode<T>>): Map<Key, ColumnSize> {\n    return new Map(Array.from(uncontrolledColumns).map(([key, col]) =>\n      [key, col.props.defaultWidth ?? this.getDefaultWidth?.(col) ?? '1fr']\n    ));\n  }\n\n  getColumnWidth(key: Key): number {\n    return this.columnWidths.get(key) ?? 0;\n  }\n\n  getColumnMinWidth(key: Key): number {\n    return this.columnMinWidths.get(key);\n  }\n\n  getColumnMaxWidth(key: Key): number {\n    return this.columnMaxWidths.get(key);\n  }\n\n  resizeColumnWidth(tableWidth: number, collection: TableCollection<T>, controlledWidths: Map<Key, ColumnSize>, uncontrolledWidths: Map<Key, ColumnSize>, col = null, width: number): Map<Key, ColumnSize> {\n    let prevColumnWidths = this.columnWidths;\n    // resizing a column\n    let resizeIndex = Infinity;\n    let resizingChanged = new Map<Key, ColumnSize>([...controlledWidths, ...uncontrolledWidths]);\n    let percentKeys = new Map();\n    let frKeysToTheRight = new Map();\n    let minWidths = new Map();\n    // freeze columns to the left to their previous pixel value\n    collection.columns.forEach((column, i) => {\n      let frKey;\n      let frValue;\n      minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n      if (col !== column.key && !column.props.width && !isStatic(uncontrolledWidths.get(column.key))) {\n        // uncontrolled don't have props.width for us, so instead get from our state\n        frKey = column.key;\n        frValue = parseFractionalUnit(uncontrolledWidths.get(column.key) as string);\n      } else if (col !== column.key && !isStatic(column.props.width) && !uncontrolledWidths.get(column.key)) {\n        // controlledWidths will be the same in the collection\n        frKey = column.key;\n        frValue = parseFractionalUnit(column.props.width);\n      } else if (col !== column.key && column.props.width?.endsWith?.('%')) {\n        percentKeys.set(column.key, column.props.width);\n      }\n      // don't freeze columns to the right of the resizing one\n      if (resizeIndex < i) {\n        if (frKey) {\n          frKeysToTheRight.set(frKey, frValue);\n        }\n        return;\n      }\n      // we already know the new size of the resizing column\n      if (column.key === col) {\n        resizeIndex = i;\n        resizingChanged.set(column.key, Math.floor(width));\n        return;\n      }\n      // freeze column to previous value\n      resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n    });\n\n    // predict pixels sizes for all columns based on resize\n    let columnWidths = calculateColumnSizes(\n      tableWidth,\n      collection.columns.map(col => ({...col.props, key: col.key})),\n      resizingChanged,\n      (i) => this.getDefaultWidth(collection.columns[i]),\n      (i) => this.getDefaultMinWidth(collection.columns[i])\n    );\n\n    // set all new column widths for onResize event\n    // columns going in will be the same order as the columns coming out\n    let newWidths = new Map<Key, ColumnSize>();\n    // set all column widths based on calculateColumnSize\n    columnWidths.forEach((width, index) => {\n      let key = collection.columns[index].key;\n      newWidths.set(key, width);\n    });\n\n    // add FR's back as they were to columns to the right\n    Array.from(frKeysToTheRight).forEach(([key]) => {\n      newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n    });\n\n    // put back in percents\n    Array.from(percentKeys).forEach(([key, width]) => {\n      // resizing locks a column to a px width\n      if (key === col) {\n        return;\n      }\n      newWidths.set(key, width);\n    });\n    return newWidths;\n  }\n\n  buildColumnWidths(tableWidth: number, collection: TableCollection<T>, widths: Map<Key, ColumnSize>) {\n    this.columnWidths = new Map();\n    this.columnMinWidths = new Map();\n    this.columnMaxWidths = new Map();\n\n    // initial layout or table/window resizing\n    let columnWidths = calculateColumnSizes(\n      tableWidth,\n      collection.columns.map(col => ({...col.props, key: col.key})),\n      widths,\n      (i) => this.getDefaultWidth(collection.columns[i]),\n      (i) => this.getDefaultMinWidth(collection.columns[i])\n    );\n\n    // columns going in will be the same order as the columns coming out\n    columnWidths.forEach((width, index) => {\n      let key = collection.columns[index].key;\n      let column = collection.columns[index];\n      this.columnWidths.set(key, width);\n      this.columnMinWidths.set(key, getMinWidth(column.props.minWidth ?? this.getDefaultMinWidth(column), tableWidth));\n      this.columnMaxWidths.set(key, getMaxWidth(column.props.maxWidth, tableWidth));\n    });\n    return this.columnWidths;\n  }\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ColumnSize} from '@react-types/table';\nimport {Key} from 'react';\n\n// numbers and percents are considered static. *fr units or a lack of units are considered dynamic.\nexport function isStatic(width: number | string): boolean {\n  return width != null && (!isNaN(width as number) || (String(width)).match(/^(\\d+)(?=%$)/) !== null);\n}\n\nexport function parseFractionalUnit(width: string): number {\n  if (!width) {\n    return 1;\n  }\n  let match = width.match(/^(.+)(?=fr$)/);\n  // if width is the incorrect format, just default it to a 1fr\n  if (!match) {\n    console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`,\n      'defaulting to \\'1fr\\'');\n    return 1;\n  }\n  return parseFloat(match[0]);\n}\n\nexport function parseStaticWidth(width: number | string, tableWidth: number): number {\n  if (typeof width === 'string') {\n    let match = width.match(/^(\\d+)(?=%$)/);\n    if (!match) {\n      throw new Error('Only percentages or numbers are supported for static column widths');\n    }\n    return tableWidth * (parseFloat(match[0]) / 100);\n  }\n  return width;\n}\n\n\nexport function getMaxWidth(maxWidth: number | string, tableWidth: number): number {\n  return maxWidth != null\n    ? parseStaticWidth(maxWidth, tableWidth)\n    : Number.MAX_SAFE_INTEGER;\n}\n\n// cannot support FR units, we'd need to know everything else in the table to do that\nexport function getMinWidth(minWidth: number | string, tableWidth: number): number {\n  return minWidth != null\n    ? parseStaticWidth(minWidth, tableWidth)\n    : 0;\n}\n\n\nexport interface IColumn {\n  minWidth?: number | string,\n  maxWidth?: number | string,\n  width?: number | string,\n  defaultWidth?: number | string,\n  key?: Key\n}\n\n/**\n * Implements the flex algorithm described in https://www.w3.org/TR/css-flexbox-1/#layout-algorithm\n * It makes a few constraint/assumptions:\n * 1. All basis values are 0 unless it is a static width, then the basis is the static width\n * 2. All flex grow and shrink values are equal to the FR specified on the column, grow and shrink for the same column are equal\n * 3. We only have one row\n * An example of the setup can be seen here https://jsfiddle.net/snowystinger/wv0ymjaf/61/ where I let the browser figure out the\n * flex of the columns.\n * Note: We differ in one key aspect, all of our column widths must be whole numbers, so we avoid browser\n * sub pixel rounding errors. To do this, we use a cascading rounding algorithm to ensure that the sum of the widths is maintained\n * while distributing the rounding remainder across the columns.\n *\n * As noted in the chrome source code, this algorithm is very accurate, but has the potential to be quadratic.\n * They have deemed this to be acceptable because the number of elements is usually small and the flex factors\n * are usually not high variance. I believe we can make the same assumptions. Particularly once resizing is\n * started, it will convert all columns to the left to static widths, so it will cut down on the number of FR columns.\n *\n * There are likely faster ways to do this, I've chosen to stick to the spec as closely as possible for readability, accuracy, and for the\n * note that this behaving quadratically is unlikely to be a problem.\n * @param availableWidth - The visible width of the table.\n * @param columns - The table defined columns.\n * @param changedColumns - Any columns we want to override, for example, during resizing.\n * @param getDefaultWidth - A function that returns the default width of a column by its index.\n * @param getDefaultMinWidth - A function that returns the default min width of a column by its index.\n */\nexport function calculateColumnSizes(availableWidth: number, columns: IColumn[], changedColumns: Map<Key, ColumnSize>, getDefaultWidth, getDefaultMinWidth) {\n  let hasNonFrozenItems = false;\n  let flexItems = columns.map((column, index) => {\n    let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : column.width ?? column.defaultWidth ?? getDefaultWidth?.(index) ?? '1fr';\n    let frozen = false;\n    let baseSize = 0;\n    let flex = 0;\n    let targetMainSize = null;\n    if (isStatic(width)) {\n      baseSize = parseStaticWidth(width, availableWidth);\n      frozen = true;\n    } else {\n      flex = parseFractionalUnit(width);\n      if (flex <= 0) {\n        frozen = true;\n      }\n    }\n\n    let min = getMinWidth(column.minWidth ?? getDefaultMinWidth?.(index) ?? 0, availableWidth);\n    let max = getMaxWidth(column.maxWidth, availableWidth);\n    let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));\n\n    // 9.7.1\n    // We don't make use of flex basis, it's always 0, so we are always in 'grow' mode.\n    // 9.7.2\n    if (frozen) {\n      targetMainSize = hypotheticalMainSize;\n    } else if (baseSize > hypotheticalMainSize) {\n      frozen = true;\n      targetMainSize = hypotheticalMainSize;\n    }\n\n    // 9.7.3\n    if (!frozen) {\n      hasNonFrozenItems = true;\n    }\n    return {\n      frozen,\n      baseSize,\n      hypotheticalMainSize,\n      min,\n      max,\n      flex,\n      targetMainSize,\n      violation: 0\n    };\n  });\n\n  // 9.7.4\n  // 9.7.4.a\n  while (hasNonFrozenItems) {\n    // 9.7.4.b\n    /**\n     * Calculate the remaining free space as for initial free space,\n     * above (9.7.3). If the sum of the unfrozen flex items’ flex factors is\n     * less than one, multiply the initial free space by this sum (of flex factors).\n     * If the magnitude of this value is less than the magnitude of\n     * the remaining free space, use this as the remaining free space.\n     */\n    let usedWidth = 0;\n    let flexFactors = 0;\n    flexItems.forEach(item => {\n      if (item.frozen) {\n        usedWidth += item.targetMainSize;\n      } else {\n        usedWidth += item.baseSize;\n        flexFactors += item.flex;\n      }\n    });\n\n    let remainingFreeSpace = availableWidth - usedWidth;\n    // we only support integer FR's, and because of hasNonFrozenItems, we know that flexFactors > 0\n    // so no need to check for flexFactors < 1\n    // 9.7.4.c\n    /**\n     * If the remaining free space is zero\n     * - Do nothing.\n     * Else // remember, we're always in grow mode\n     * - Find the ratio of the item’s flex grow factor to the\n     * sum of the flex grow factors of all unfrozen items on\n     * the line. Set the item’s target main size to its flex\n     * base size plus a fraction of the remaining free space\n     * proportional to the ratio.\n     */\n    if (remainingFreeSpace > 0) {\n      flexItems.forEach((item) => {\n        if (!item.frozen) {\n          let ratio = item.flex / flexFactors;\n          item.targetMainSize = item.baseSize + (ratio * remainingFreeSpace);\n        }\n      });\n    }\n\n    // 9.7.4.d\n    /**\n     * Fix min/max violations. Clamp each non-frozen item’s\n     * target main size by its used min and max main sizes\n     * and floor its content-box size at zero. If the item’s\n     * target main size was made smaller by this, it’s a max\n     * violation. If the item’s target main size was made\n     * larger by this, it’s a min violation.\n     */\n    let totalViolation = 0;\n    flexItems.forEach(item => {\n      item.violation = 0;\n      if (!item.frozen) {\n        let {min, max, targetMainSize} = item;\n        item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));\n\n        item.violation = item.targetMainSize - targetMainSize;\n        totalViolation += item.violation;\n      }\n    });\n\n    // 9.7.4.e\n    /**\n     * Freeze over-flexed items. The total violation is the\n     * sum of the adjustments from the previous step\n     * ∑(clamped size - unclamped size). If the total violation is:\n     * Zero\n     * - Freeze all items.\n     *\n     * Positive\n     * - Freeze all the items with min violations.\n     *\n     * Negative\n     * - Freeze all the items with max violations.\n     */\n    hasNonFrozenItems = false;\n    flexItems.forEach(item => {\n      if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation)) {\n        item.frozen = true;\n      } else if (!item.frozen) {\n        hasNonFrozenItems = true;\n      }\n    });\n  }\n\n  return cascadeRounding(flexItems);\n}\n\nfunction cascadeRounding(flexItems): number[] {\n  /*\n  Given an array of floats that sum to an integer, this rounds the floats\n  and returns an array of integers with the same sum.\n  */\n\n  let fpTotal = 0;\n  let intTotal = 0;\n  let roundedArray = [];\n  flexItems.forEach(function (item) {\n    let float = item.targetMainSize;\n    let integer = Math.round(float + fpTotal) - intTotal;\n    fpTotal += float;\n    intTotal += integer;\n    roundedArray.push(integer);\n  });\n\n  return roundedArray;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {GridState, useGridState} from '@react-stately/grid';\nimport {TableCollection as ITableCollection, TableBodyProps, TableHeaderProps} from '@react-types/table';\nimport {Key, ReactElement, useCallback, useMemo, useState} from 'react';\nimport {MultipleSelectionStateProps} from '@react-stately/selection';\nimport {Node, SelectionMode, Sortable, SortDescriptor, SortDirection} from '@react-types/shared';\nimport {TableCollection} from './TableCollection';\nimport {useCollection} from '@react-stately/collections';\n\nexport interface TableState<T> extends GridState<T, ITableCollection<T>> {\n  /** A collection of rows and columns in the table. */\n  collection: ITableCollection<T>,\n  /** Whether the row selection checkboxes should be displayed. */\n  showSelectionCheckboxes: boolean,\n  /** The current sorted column and direction. */\n  sortDescriptor: SortDescriptor,\n  /** Calls the provided onSortChange handler with the provided column key and sort direction. */\n  sort(columnKey: Key, direction?: 'ascending' | 'descending'): void,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean,\n  /** Set whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  setKeyboardNavigationDisabled: (val: boolean) => void\n}\n\nexport interface CollectionBuilderContext<T> {\n  showSelectionCheckboxes: boolean,\n  showDragButtons: boolean,\n  selectionMode: SelectionMode,\n  columns: Node<T>[]\n}\n\nexport interface TableStateProps<T> extends MultipleSelectionStateProps, Sortable {\n  /** The elements that make up the table. Includes the TableHeader, TableBody, Columns, and Rows. */\n  children?: [ReactElement<TableHeaderProps<T>>, ReactElement<TableBodyProps<T>>],\n  /** A list of row keys to disable. */\n  disabledKeys?: Iterable<Key>,\n  /** A pre-constructed collection to use instead of building one from items and children. */\n  collection?: ITableCollection<T>,\n  /** Whether the row selection checkboxes should be displayed. */\n  showSelectionCheckboxes?: boolean,\n  /** Whether the row drag button should be displayed.\n   * @private\n   */\n  showDragButtons?: boolean\n}\n\nconst OPPOSITE_SORT_DIRECTION = {\n  ascending: 'descending' as SortDirection,\n  descending: 'ascending' as SortDirection\n};\n\n/**\n * Provides state management for a table component. Handles building a collection\n * of columns and rows from props. In addition, it tracks row selection and manages sort order changes.\n */\nexport function useTableState<T extends object>(props: TableStateProps<T>): TableState<T> {\n  let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = useState(false);\n  let {selectionMode = 'none', showSelectionCheckboxes, showDragButtons} = props;\n\n  let context = useMemo(() => ({\n    showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== 'none',\n    showDragButtons: showDragButtons,\n    selectionMode,\n    columns: []\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }), [props.children, showSelectionCheckboxes, selectionMode, showDragButtons]);\n\n  let collection = useCollection<T, ITableCollection<T>>(\n    props,\n    useCallback((nodes) => new TableCollection(nodes, null, context), [context]),\n    context\n  );\n  let {disabledKeys, selectionManager} = useGridState({\n    ...props,\n    collection,\n    disabledBehavior: props.disabledBehavior || 'selection'\n  });\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager,\n    showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n    sortDescriptor: props.sortDescriptor,\n    isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n    setKeyboardNavigationDisabled,\n    sort(columnKey: Key, direction?: 'ascending' | 'descending') {\n      props.onSortChange({\n        column: columnKey,\n        direction: direction ?? (props.sortDescriptor?.column === columnKey\n          ? OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction]\n          : 'ascending')\n      });\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {getFirstItem, getLastItem} from '@react-stately/collections';\nimport {GridCollection} from '@react-stately/grid';\nimport {GridNode} from '@react-types/grid';\nimport {TableCollection as ITableCollection} from '@react-types/table';\nimport {Key} from 'react';\n\ninterface GridCollectionOptions {\n  showSelectionCheckboxes?: boolean,\n  showDragButtons?: boolean\n}\n\nconst ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\nlet ROW_HEADER_COLUMN_KEY_DRAG = 'row-header-column-' + Math.random().toString(36).slice(2);\nwhile (ROW_HEADER_COLUMN_KEY === ROW_HEADER_COLUMN_KEY_DRAG) {\n  ROW_HEADER_COLUMN_KEY_DRAG = 'row-header-column-' + Math.random().toString(36).slice(2);\n}\n\n/** @private */\nexport function buildHeaderRows<T>(keyMap: Map<Key, GridNode<T>>, columnNodes: GridNode<T>[]): GridNode<T>[] {\n  if (columnNodes.length === 0) {\n    return [];\n  }\n\n  let columns: GridNode<T>[][] = [];\n  let seen = new Map();\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n\n    while (parentKey) {\n      let parent: GridNode<T> = keyMap.get(parentKey);\n      if (!parent) {\n        break;\n      }\n\n      // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n      if (seen.has(parent)) {\n        parent.colspan++;\n\n        let {column, index} = seen.get(parent);\n        if (index > col.length) {\n          break;\n        }\n\n        for (let i = index; i < col.length; i++) {\n          column.splice(i, 0, null);\n        }\n\n        // Adjust shifted indices\n        for (let i = col.length; i < column.length; i++) {\n          // eslint-disable-next-line max-depth\n          if (column[i] && seen.has(column[i])) {\n            seen.get(column[i]).index = i;\n          }\n        }\n      } else {\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {column: col, index: col.length - 1});\n      }\n\n      parentKey = parent.parentKey;\n    }\n\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows = Array(maxLength).fill(0).map(() => []);\n\n  // Convert columns into rows.\n  let colIndex = 0;\n  for (let column of columns) {\n    let i = maxLength - 1;\n    for (let item of column) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n        if (rowLength < colIndex) {\n          let placeholder: GridNode<T> = {\n            type: 'placeholder',\n            key: 'placeholder-' + item.key,\n            colspan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: null\n          };\n\n          // eslint-disable-next-line max-depth\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n\n          row.push(placeholder);\n        }\n\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n\n        item.level = i;\n        item.colIndex = colIndex;\n        row.push(item);\n      }\n\n      i--;\n    }\n\n    colIndex++;\n  }\n\n  // Add placeholders at the end of each row that is shorter than the maximum\n  let i = 0;\n  for (let row of headerRows) {\n    let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n    if (rowLength < columnNodes.length) {\n      let placeholder: GridNode<T> = {\n        type: 'placeholder',\n        key: 'placeholder-' + row[row.length - 1].key,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: null,\n        prevKey: row[row.length - 1].key\n      };\n\n      row.push(placeholder);\n    }\n\n    i++;\n  }\n\n  return headerRows.map((childNodes, index) => {\n    let row: GridNode<T> = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes,\n      textValue: null\n    };\n\n    return row;\n  });\n}\n\nexport class TableCollection<T> extends GridCollection<T> implements ITableCollection<T> {\n  headerRows: GridNode<T>[];\n  columns: GridNode<T>[];\n  rowHeaderColumnKeys: Set<Key>;\n  body: GridNode<T>;\n  _size: number = 0;\n\n  constructor(nodes: Iterable<GridNode<T>>, prev?: ITableCollection<T>, opts?: GridCollectionOptions) {\n    let rowHeaderColumnKeys: Set<Key> = new Set();\n    let body: GridNode<T>;\n    let columns: GridNode<T>[] = [];\n    // Add cell for selection checkboxes if needed.\n    if (opts?.showSelectionCheckboxes) {\n      let rowHeaderColumn: GridNode<T> = {\n        type: 'column',\n        key: ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: opts?.showDragButtons ? 1 : 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n\n      columns.unshift(rowHeaderColumn);\n    }\n\n    // Add cell for drag buttons if needed.\n    if (opts?.showDragButtons) {\n      let rowHeaderColumn: GridNode<T> = {\n        type: 'column',\n        key: ROW_HEADER_COLUMN_KEY_DRAG,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isDragButtonCell: true\n        }\n      };\n\n      columns.unshift(rowHeaderColumn);\n    }\n\n    let rows = [];\n    let columnKeyMap = new Map();\n    let visit = (node: GridNode<T>) => {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n        case 'column':\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n\n            if (node.props.isRowHeader) {\n              rowHeaderColumnKeys.add(node.key);\n            }\n          }\n          break;\n        case 'item':\n          rows.push(node);\n          return; // do not go into childNodes\n      }\n      for (let child of node.childNodes) {\n        visit(child);\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let headerRows = buildHeaderRows(columnKeyMap, columns) as GridNode<T>[];\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    });\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body;\n    this.headerRows = headerRows;\n    this._size = [...body.childNodes].length;\n\n    // Default row header column to the first one.\n    if (this.rowHeaderColumnKeys.size === 0) {\n      if (opts?.showSelectionCheckboxes) {\n        if (opts?.showDragButtons) {\n          this.rowHeaderColumnKeys.add(this.columns[2].key);\n        } else {\n          this.rowHeaderColumnKeys.add(this.columns[1].key);\n        }\n      } else {\n        this.rowHeaderColumnKeys.add(this.columns[0].key);\n      }\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.body.childNodes;\n  }\n\n  get size() {\n    return this._size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return getFirstItem(this.body.childNodes)?.key;\n  }\n\n  getLastKey() {\n    return getLastItem(this.body.childNodes)?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  getTextValue(key: Key): string {\n    let row = this.getItem(key);\n    if (!row) {\n      return '';\n    }\n\n    // If the row has a textValue, use that.\n    if (row.textValue) {\n      return row.textValue;\n    }\n\n    // Otherwise combine the text of each of the row header columns.\n    let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n    if (rowHeaderColumnKeys) {\n      let text = [];\n      for (let cell of row.childNodes) {\n        let column = this.columns[cell.index];\n        if (rowHeaderColumnKeys.has(column.key) && cell.textValue) {\n          text.push(cell.textValue);\n        }\n\n        if (text.length === rowHeaderColumnKeys.size) {\n          break;\n        }\n      }\n\n      return text.join(' ');\n    }\n\n    return '';\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilderContext} from './useTableState';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {TableHeaderProps} from '@react-types/table';\n\nfunction TableHeader<T>(props: TableHeaderProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nTableHeader.getCollectionNode = function* getCollectionNode<T>(props: TableHeaderProps<T>, context: CollectionBuilderContext<T>): Generator<PartialNode<T>, void, any> {\n  let {children, columns} = props;\n\n  // Clear columns so they aren't double added in strict mode.\n  context.columns = [];\n\n  if (typeof children === 'function') {\n    if (!columns) {\n      throw new Error('props.children was a function but props.columns is missing');\n    }\n\n    for (let column of columns) {\n      yield {\n        type: 'column',\n        value: column,\n        renderer: children\n      };\n    }\n  } else {\n    let columns: PartialNode<T>[] = [];\n    React.Children.forEach(children, column => {\n      columns.push({\n        type: 'column',\n        element: column\n      });\n    });\n\n    yield* columns;\n  }\n};\n\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _TableHeader = TableHeader as <T>(props: TableHeaderProps<T>) => JSX.Element;\nexport {_TableHeader as TableHeader};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {TableBodyProps} from '@react-types/table';\n\nfunction TableBody<T>(props: TableBodyProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nTableBody.getCollectionNode = function* getCollectionNode<T>(props: TableBodyProps<T>): Generator<PartialNode<T>> {\n  let {children, items} = props;\n  yield {\n    type: 'body',\n    hasChildNodes: true,\n    props,\n    *childNodes() {\n      if (typeof children === 'function') {\n        if (!items) {\n          throw new Error('props.children was a function but props.items is missing');\n        }\n\n        for (let item of items) {\n          yield {\n            type: 'item',\n            value: item,\n            renderer: children\n          };\n        }\n      } else {\n        let items: PartialNode<T>[] = [];\n        React.Children.forEach(children, item => {\n          items.push({\n            type: 'item',\n            element: item\n          });\n        });\n\n        yield* items;\n      }\n    }\n  };\n};\n\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _TableBody = TableBody as <T>(props: TableBodyProps<T>) => JSX.Element;\nexport {_TableBody as TableBody};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilderContext} from './useTableState';\nimport {ColumnProps} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\n\nfunction Column<T>(props: ColumnProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nColumn.getCollectionNode = function* getCollectionNode<T>(props: ColumnProps<T>, context: CollectionBuilderContext<T>): Generator<PartialNode<T>, void, GridNode<T>[]> {\n  let {title, children, childColumns} = props;\n\n  let rendered = title || children;\n  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'];\n\n  let fullNodes = yield {\n    type: 'column',\n    hasChildNodes: !!childColumns || (title && React.Children.count(children) > 0),\n    rendered,\n    textValue,\n    props,\n    *childNodes() {\n      if (childColumns) {\n        for (let child of childColumns) {\n          yield {\n            type: 'column',\n            value: child\n          };\n        }\n      } else if (title) {\n        let childColumns: PartialNode<T>[] = [];\n        React.Children.forEach(children, child => {\n          childColumns.push({\n            type: 'column',\n            element: child as ReactElement<ColumnProps<T>>\n          });\n        });\n\n        yield* childColumns;\n      }\n    },\n    shouldInvalidate(newContext: CollectionBuilderContext<T>) {\n      // This is a bit of a hack, but it works.\n      // If this method is called, then there's a cached version of this node available.\n      // But, we need to keep the list of columns in the new context up to date.\n      updateContext(newContext);\n      return false;\n    }\n  };\n\n  let updateContext = (context: CollectionBuilderContext<T>) => {\n    // register leaf columns on the context so that <Row> can access them\n    for (let node of fullNodes) {\n      if (!node.hasChildNodes) {\n        context.columns.push(node);\n      }\n    }\n  };\n\n  updateContext(context);\n};\n\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Column = Column as <T>(props: ColumnProps<T>) => JSX.Element;\nexport {_Column as Column};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilderContext} from './useTableState';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {RowProps} from '@react-types/table';\n\nfunction Row<T>(props: RowProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nRow.getCollectionNode = function* getCollectionNode<T>(props: RowProps<T>, context: CollectionBuilderContext<T>): Generator<PartialNode<T>> {\n  let {children, textValue, UNSTABLE_childItems} = props;\n\n  yield {\n    type: 'item',\n    props: props,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: true,\n    *childNodes() {\n      // Process cells first\n      if (context.showDragButtons) {\n        yield {\n          type: 'cell',\n          key: 'header-drag', // this is combined with the row key by CollectionBuilder\n          props: {\n            isDragButtonCell: true\n          }\n        };\n      }\n\n      if (context.showSelectionCheckboxes && context.selectionMode !== 'none') {\n        yield {\n          type: 'cell',\n          key: 'header', // this is combined with the row key by CollectionBuilder\n          props: {\n            isSelectionCell: true\n          }\n        };\n      }\n\n      if (typeof children === 'function') {\n        for (let column of context.columns) {\n          yield {\n            type: 'cell',\n            element: children(column.key),\n            key: column.key // this is combined with the row key by CollectionBuilder\n          };\n        }\n\n        if (UNSTABLE_childItems) {\n          for (let child of UNSTABLE_childItems) {\n            // Note: in order to reuse the render function of TableBody for our child rows, we just need to yield a type and a value here. CollectionBuilder will then look up\n            // the parent renderer and use that to build the full node of this child row, using the value provided here to generate the cells\n            yield {\n              type: 'item',\n              value: child\n            };\n          }\n        }\n      } else {\n        let cells: PartialNode<T>[] = [];\n        let childRows: PartialNode<T>[] = [];\n        React.Children.forEach(children, node => {\n          if (node.type === Row) {\n            if (cells.length < context.columns.length) {\n              throw new Error('All of a Row\\'s child Cells must be positioned before any child Rows.');\n            }\n\n            childRows.push({\n              type: 'item',\n              element: node\n            });\n          } else {\n            cells.push({\n              type: 'cell',\n              element: node\n            });\n          }\n        });\n\n        if (cells.length !== context.columns.length) {\n          throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n        }\n\n        yield* cells;\n        yield* childRows;\n      }\n    },\n    shouldInvalidate(newContext: CollectionBuilderContext<T>) {\n      // Invalidate all rows if the columns changed.\n      return newContext.columns.length !== context.columns.length ||\n        newContext.columns.some((c, i) => c.key !== context.columns[i].key) ||\n        newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes ||\n        newContext.showDragButtons !== context.showDragButtons ||\n        newContext.selectionMode !== context.selectionMode;\n    }\n  };\n};\n\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Row = Row as <T>(props: RowProps<T>) => JSX.Element;\nexport {_Row as Row};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CellProps} from '@react-types/table';\nimport {PartialNode} from '@react-stately/collections';\nimport {ReactElement} from 'react';\n\nfunction Cell(props: CellProps): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nCell.getCollectionNode = function* getCollectionNode<T>(props: CellProps): Generator<PartialNode<T>> {\n  let {children} = props;\n\n  let textValue = props.textValue || (typeof children === 'string' ? children : '') || props['aria-label'] || '';\n  yield {\n    type: 'cell',\n    props: props,\n    rendered: children,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: false\n  };\n};\n\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Cell = Cell as (props: CellProps) => JSX.Element;\nexport {_Cell as Cell};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilder} from '@react-stately/collections';\nimport {GridNode} from '@react-types/grid';\nimport {Key, ReactElement, useMemo} from 'react';\nimport {TableCollection} from './TableCollection';\nimport {tableNestedRows} from '@react-stately/flags';\nimport {TableState, TableStateProps, useTableState} from './useTableState';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface TreeGridState<T> extends TableState<T> {\n  /** A set of keys for items that are expanded. */\n  expandedKeys: 'all' | Set<Key>,\n  /** Toggles the expanded state for a row by its key. */\n  toggleKey(key: Key): void,\n  /** The key map containing nodes representing the collection's tree grid structure. */\n  keyMap: Map<Key, GridNode<T>>,\n  /** The number of leaf columns provided by the user. */\n  userColumnCount: number\n}\n\nexport interface TreeGridStateProps<T> extends Omit<TableStateProps<T>, 'collection'> {\n  /** The currently expanded keys in the collection (controlled). */\n  UNSTABLE_expandedKeys?: 'all' | Iterable<Key>,\n  /** The initial expanded keys in the collection (uncontrolled). */\n  UNSTABLE_defaultExpandedKeys?: 'all' | Iterable<Key>,\n  /** Handler that is called when items are expanded or collapsed. */\n  UNSTABLE_onExpandedChange?: (keys: Set<Key>) => any\n}\n\n/**\n * Provides state management for a tree grid component. Handles building a collection\n * of columns and rows from props. In addition, it tracks and manages expanded rows, row selection, and sort order changes.\n */\nexport function UNSTABLE_useTreeGridState<T extends object>(props: TreeGridStateProps<T>): TreeGridState<T> {\n  let {\n    selectionMode = 'none',\n    showSelectionCheckboxes,\n    showDragButtons,\n    UNSTABLE_expandedKeys: propExpandedKeys,\n    UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys,\n    UNSTABLE_onExpandedChange,\n    children\n  } = props;\n\n  if (!tableNestedRows()) {\n    throw new Error('Feature flag for table nested rows must be enabled to use useTreeGridState.');\n  }\n\n  let [expandedKeys, setExpandedKeys] = useControlledState(\n    propExpandedKeys ? convertExpanded(propExpandedKeys) : undefined,\n    propDefaultExpandedKeys ? convertExpanded(propDefaultExpandedKeys) : new Set(),\n    UNSTABLE_onExpandedChange\n  );\n\n  let context = useMemo(() => ({\n    showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== 'none',\n    showDragButtons: showDragButtons,\n    selectionMode,\n    columns: []\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }), [children, showSelectionCheckboxes, selectionMode, showDragButtons]);\n\n  let builder = useMemo(() => new CollectionBuilder<T>(), []);\n  let nodes = useMemo(() => builder.build({children: children as ReactElement[]}, context), [builder, children, context]);\n  let treeGridCollection = useMemo(() => {\n    return generateTreeGridCollection<T>(nodes, {showSelectionCheckboxes, showDragButtons, expandedKeys});\n  }, [nodes, showSelectionCheckboxes, showDragButtons, expandedKeys]);\n\n  let onToggle = (key: Key) => {\n    setExpandedKeys(toggleKey(expandedKeys, key, treeGridCollection));\n  };\n\n  let collection = useMemo(() => {\n    return new TableCollection(treeGridCollection.tableNodes, null, context);\n  }, [context, treeGridCollection.tableNodes]);\n\n  let tableState = useTableState({...props, collection});\n  return {\n    ...tableState,\n    keyMap: treeGridCollection.keyMap,\n    userColumnCount: treeGridCollection.userColumnCount,\n    expandedKeys,\n    toggleKey: onToggle\n  };\n}\n\nfunction toggleKey<T>(currentExpandedKeys: 'all' | Set<Key>, key: Key, collection: TreeGridCollection<T>): Set<Key> {\n  let updatedExpandedKeys: Set<Key>;\n  if (currentExpandedKeys === 'all') {\n    updatedExpandedKeys = new Set(collection.flattenedRows.filter(row => row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map(row => row.key));\n    updatedExpandedKeys.delete(key);\n  } else {\n    updatedExpandedKeys = new Set(currentExpandedKeys);\n    if (updatedExpandedKeys.has(key)) {\n      updatedExpandedKeys.delete(key);\n    } else {\n      updatedExpandedKeys.add(key);\n    }\n  }\n\n  return updatedExpandedKeys;\n}\n\nfunction convertExpanded(expanded: 'all' | Iterable<Key>): 'all' | Set<Key> {\n  if (!expanded) {\n    return new Set<Key>();\n  }\n\n  return expanded === 'all'\n    ? 'all'\n    : new Set(expanded);\n}\n\ninterface TreeGridCollectionOptions {\n  showSelectionCheckboxes?: boolean,\n  showDragButtons?: boolean,\n  expandedKeys: 'all' | Set<Key>\n}\n\ninterface TreeGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>>,\n  tableNodes: GridNode<T>[],\n  flattenedRows: GridNode<T>[],\n  userColumnCount: number\n}\nfunction generateTreeGridCollection<T>(nodes, opts: TreeGridCollectionOptions): TreeGridCollection<T> {\n  let {\n    expandedKeys = new Set()\n  } = opts;\n\n  let body: GridNode<T>;\n  let flattenedRows = [];\n  let columnCount = 0;\n  let userColumnCount = 0;\n  let originalColumns = [];\n  let keyMap = new Map();\n\n  if (opts?.showSelectionCheckboxes) {\n    columnCount++;\n  }\n\n  if (opts?.showDragButtons) {\n    columnCount++;\n  }\n\n  let topLevelRows = [];\n  let visit = (node: GridNode<T>) => {\n    switch (node.type) {\n      case 'body':\n        body = node;\n        keyMap.set(body.key, body);\n        break;\n      case 'column':\n        if (!node.hasChildNodes) {\n          userColumnCount++;\n        }\n        break;\n      case 'item':\n        topLevelRows.push(node);\n        return;\n    }\n\n    for (let child of node.childNodes) {\n      visit(child);\n    }\n  };\n\n  for (let node of nodes) {\n    if (node.type === 'column') {\n      originalColumns.push(node);\n    }\n    visit(node);\n  }\n  columnCount += userColumnCount;\n\n  // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n  let globalRowCount = 0;\n  let visitNode = (node: GridNode<T>, i?: number) => {\n    // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n    // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n    // values automatically calculated via CollectionBuilder\n    if (node.type === 'item') {\n      let childNodes = [];\n      for (let child of node.childNodes) {\n        if (child.type === 'cell') {\n          let cellClone = {...child};\n          if (cellClone.index + 1 === columnCount) {\n            cellClone.nextKey = null;\n          }\n          childNodes.push({...cellClone});\n        }\n      }\n      let clone = {...node, childNodes: childNodes, parentKey: body.key, level: 1, index: globalRowCount++};\n      flattenedRows.push(clone);\n    }\n\n    let newProps = {};\n\n    // Assign indexOfType to cells and rows for aria-posinset\n    if (node.type !== 'placeholder' && node.type !== 'column') {\n      newProps['indexOfType'] = i;\n    }\n\n    // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n    // via .childNodes returns the same object as the one found via keyMap look up\n    Object.assign(node, newProps);\n    keyMap.set(node.key, node);\n\n    let lastNode: GridNode<T>;\n    let rowIndex = 0;\n    for (let child of node.childNodes) {\n      if (!(child.type === 'item' && expandedKeys !== 'all' && !expandedKeys.has(node.key))) {\n        if (child.parentKey == null) {\n          // if child is a cell/expanded row/column and the parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n\n        if (lastNode) {\n          lastNode.nextKey = child.key;\n          child.prevKey = lastNode.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        if (child.type === 'item') {\n          visitNode(child, rowIndex++);\n        } else {\n          // We enforce that the cells come before rows so can just reuse cell index\n          visitNode(child, child.index);\n        }\n\n        lastNode = child;\n      }\n    }\n\n    if (lastNode) {\n      lastNode.nextKey = null;\n    }\n  };\n\n  let last: GridNode<T>;\n  topLevelRows.forEach((node: GridNode<T>, i) => {\n    visitNode(node as GridNode<T>, i);\n\n    if (last) {\n      last.nextKey = node.key;\n      node.prevKey = last.key;\n    } else {\n      node.prevKey = null;\n    }\n\n    last = node;\n  });\n\n  if (last) {\n    last.nextKey = null;\n  }\n\n  return {\n    keyMap,\n    userColumnCount,\n    flattenedRows,\n    tableNodes: [...originalColumns, {...body, childNodes: flattenedRows}]\n  };\n}\n"],"names":[],"version":3,"file":"main.js.map"}