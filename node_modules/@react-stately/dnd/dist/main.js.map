{"mappings":"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","sources":["packages/@react-stately/dnd/src/index.ts","packages/@react-stately/dnd/src/useDraggableCollectionState.ts","packages/@react-stately/dnd/src/useDroppableCollectionState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {DraggableCollectionStateOptions, DraggableCollectionState} from './useDraggableCollectionState';\nexport type {DroppableCollectionStateOptions, DroppableCollectionState} from './useDroppableCollectionState';\nexport {useDraggableCollectionState} from './useDraggableCollectionState';\nexport {useDroppableCollectionState} from './useDroppableCollectionState';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DraggableCollectionEndEvent, DraggableCollectionProps, DragItem, DragMoveEvent, DragPreviewRenderer, DragStartEvent, DropOperation, Node} from '@react-types/shared';\nimport {Key, RefObject, useRef, useState} from 'react';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\nexport interface DraggableCollectionStateOptions extends DraggableCollectionProps {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager\n}\n\nexport interface DraggableCollectionState {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** The key of the item that initiated a drag. */\n  draggedKey: Key | null,\n  /** The keys of the items that are currently being dragged. */\n  draggingKeys: Set<Key>,\n  /** Returns whether the given key is currently being dragged. */\n  isDragging(key: Key): boolean,\n  /** Returns the keys of the items that will be dragged with the given key (e.g. selected items). */\n  getKeysForDrag(key: Key): Set<Key>,\n  /** Returns the items to drag for the given key. */\n  getItems(key: Key): DragItem[],\n  /** The ref of the element that will be rendered as the drag preview while dragging. */\n  preview?: RefObject<DragPreviewRenderer>,\n  /** Function that returns the drop operations that are allowed for the dragged items. If not provided, all drop operations are allowed. */\n  getAllowedDropOperations?: () => DropOperation[],\n  /** Begins a drag for the given key. This triggers the onDragStart event. */\n  startDrag(key: Key, event: DragStartEvent): void,\n  /** Triggers an onDragMove event. */\n  moveDrag(event: DragMoveEvent): void,\n  /** Ends the current drag, and emits an onDragEnd event. */\n  endDrag(event: DraggableCollectionEndEvent): void\n}\n\n/**\n * Manages state for a draggable collection.\n */\nexport function useDraggableCollectionState(props: DraggableCollectionStateOptions): DraggableCollectionState {\n  let {\n    getItems,\n    collection,\n    selectionManager,\n    onDragStart,\n    onDragMove,\n    onDragEnd,\n    preview,\n    getAllowedDropOperations\n  } = props;\n  let [, setDragging] = useState(false);\n  let draggingKeys = useRef(new Set<Key>());\n  let draggedKey = useRef(null);\n  let getKeys = (key: Key) => {\n    // The clicked item is always added to the drag. If it is selected, then all of the\n    // other selected items are also dragged. If it is not selected, the only the clicked\n    // item is dragged. This matches native macOS behavior.\n    let keys = new Set(\n      selectionManager.isSelected(key)\n        ? new Set([...selectionManager.selectedKeys].filter(key => !!collection.getItem(key)))\n        : []\n    );\n\n    keys.add(key);\n    return keys;\n  };\n\n  return {\n    collection,\n    selectionManager,\n    get draggedKey() {\n      return draggedKey.current;\n    },\n    get draggingKeys() {\n      return draggingKeys.current;\n    },\n    isDragging(key) {\n      return draggingKeys.current.has(key);\n    },\n    getKeysForDrag: getKeys,\n    getItems(key) {\n      return getItems(getKeys(key));\n    },\n    preview,\n    getAllowedDropOperations,\n    startDrag(key, event) {\n      let keys = getKeys(key);\n      draggingKeys.current = keys;\n      draggedKey.current = key;\n      selectionManager.setFocused(false);\n      setDragging(true);\n      if (typeof onDragStart === 'function') {\n        onDragStart({\n          ...event,\n          keys\n        });\n      }\n    },\n    moveDrag(event) {\n      if (typeof onDragMove === 'function') {\n        onDragMove({\n          ...event,\n          keys: draggingKeys.current\n        });\n      }\n    },\n    endDrag(event) {\n      let {\n        isInternal\n      } = event;\n\n      if (typeof onDragEnd === 'function') {\n        onDragEnd({\n          ...event,\n          keys: draggingKeys.current,\n          isInternal\n        });\n      }\n\n      draggingKeys.current = new Set();\n      draggedKey.current = null;\n      setDragging(false);\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DragTypes, DropOperation, DroppableCollectionProps, DropTarget, ItemDropTarget, Node} from '@react-types/shared';\nimport {Key, useCallback, useRef, useState} from 'react';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\ninterface DropOperationEvent {\n  target: DropTarget,\n  types: DragTypes,\n  allowedOperations: DropOperation[],\n  isInternal: boolean,\n  draggingKeys: Set<Key>\n}\n\nexport interface DroppableCollectionStateOptions extends Omit<DroppableCollectionProps, 'onDropMove' | 'onDropActivate'> {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager\n}\n\nexport interface DroppableCollectionState {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** The current drop target. */\n  target: DropTarget | null,\n  /** Sets the current drop target. */\n  setTarget(target: DropTarget): void,\n  /** Returns whether the given target is equivalent to the current drop target. */\n  isDropTarget(target: DropTarget): boolean,\n  /** Returns the drop operation for the given parameters. */\n  getDropOperation(e: DropOperationEvent): DropOperation\n}\n\n/**\n * Manages state for a droppable collection.\n */\nexport function useDroppableCollectionState(props: DroppableCollectionStateOptions): DroppableCollectionState  {\n  let {\n    acceptedDragTypes = 'all',\n    onInsert,\n    onRootDrop,\n    onItemDrop,\n    onReorder,\n    shouldAcceptItemDrop,\n    collection,\n    selectionManager,\n    onDropEnter,\n    getDropOperation,\n    onDrop\n  } = props;\n  let [target, setTarget] = useState<DropTarget>(null);\n  let targetRef = useRef<DropTarget>(null);\n\n  let getOppositeTarget = (target: ItemDropTarget): ItemDropTarget => {\n    if (target.dropPosition === 'before') {\n      let key = collection.getKeyBefore(target.key);\n      return key != null ? {type: 'item', key, dropPosition: 'after'} : null;\n    } else if (target.dropPosition === 'after') {\n      let key = collection.getKeyAfter(target.key);\n      return key != null ? {type: 'item', key, dropPosition: 'before'} : null;\n    }\n  };\n\n  let defaultGetDropOperation = useCallback((e: DropOperationEvent) => {\n    let {\n      target,\n      types,\n      allowedOperations,\n      isInternal,\n      draggingKeys\n    } = e;\n\n    if (acceptedDragTypes === 'all' || acceptedDragTypes.some(type => types.has(type))) {\n      let isValidInsert = onInsert && target.type === 'item' && !isInternal && (target.dropPosition === 'before' || target.dropPosition === 'after');\n      let isValidReorder = onReorder && target.type === 'item' && isInternal && (target.dropPosition === 'before' || target.dropPosition === 'after');\n      // Feedback was that internal root drop was weird so preventing that from happening\n      let isValidRootDrop = onRootDrop && target.type === 'root' && !isInternal;\n      // Automatically prevent items (i.e. folders) from being dropped on themselves.\n      let isValidOnItemDrop = onItemDrop && target.type === 'item' && target.dropPosition === 'on' && !(isInternal && draggingKeys.has(target.key)) && (!shouldAcceptItemDrop || shouldAcceptItemDrop(target, types));\n\n      if (onDrop || isValidInsert || isValidReorder || isValidRootDrop || isValidOnItemDrop) {\n        if (getDropOperation) {\n          return getDropOperation(target, types, allowedOperations);\n        } else {\n          return allowedOperations[0];\n        }\n      }\n    }\n\n    return 'cancel';\n  }, [acceptedDragTypes, getDropOperation, onInsert, onRootDrop, onItemDrop, shouldAcceptItemDrop, onReorder, onDrop]);\n\n  return {\n    collection,\n    selectionManager,\n    target,\n    setTarget(newTarget) {\n      if (this.isDropTarget(newTarget)) {\n        return;\n      }\n\n      let target = targetRef.current;\n      if (target && typeof props.onDropExit === 'function') {\n        props.onDropExit({\n          type: 'dropexit',\n          x: 0, // todo\n          y: 0,\n          target\n        });\n      }\n\n      if (newTarget && typeof onDropEnter === 'function') {\n        onDropEnter({\n          type: 'dropenter',\n          x: 0, // todo\n          y: 0,\n          target: newTarget\n        });\n      }\n\n      targetRef.current = newTarget;\n      setTarget(newTarget);\n    },\n    isDropTarget(dropTarget) {\n      let target = targetRef.current;\n      if (isEqualDropTarget(dropTarget, target)) {\n        return true;\n      }\n\n      // Check if the targets point at the same point between two items, one referring before, and the other after.\n      if (\n        dropTarget?.type === 'item' &&\n        target?.type === 'item' &&\n        dropTarget.key !== target.key &&\n        dropTarget.dropPosition !== target.dropPosition &&\n        dropTarget.dropPosition !== 'on' &&\n        target.dropPosition !== 'on'\n      ) {\n        return isEqualDropTarget(getOppositeTarget(dropTarget), target) ||\n          isEqualDropTarget(dropTarget, getOppositeTarget(target));\n      }\n\n      return false;\n    },\n    getDropOperation(e) {\n      return defaultGetDropOperation(e);\n    }\n  };\n}\n\nfunction isEqualDropTarget(a: DropTarget, b: DropTarget) {\n  if (!a) {\n    return !b;\n  }\n\n  switch (a.type) {\n    case 'root':\n      return b?.type === 'root';\n    case 'item':\n      return b?.type === 'item' && b?.key === a.key && b?.dropPosition === a.dropPosition;\n  }\n}\n"],"names":[],"version":3,"file":"main.js.map"}