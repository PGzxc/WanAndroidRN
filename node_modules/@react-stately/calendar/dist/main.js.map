{"mappings":"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","sources":["packages/@react-stately/calendar/src/index.ts","packages/@react-stately/calendar/src/useCalendarState.ts","packages/@react-stately/calendar/src/utils.ts","packages/@react-stately/calendar/src/useRangeCalendarState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useCalendarState} from './useCalendarState';\nexport {useRangeCalendarState} from './useRangeCalendarState';\n\nexport type {CalendarStateOptions} from './useCalendarState';\nexport type {RangeCalendarStateOptions} from './useRangeCalendarState';\nexport type {CalendarState, RangeCalendarState} from './types'; \n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {alignCenter, alignEnd, alignStart, constrainStart, constrainValue, isInvalid, previousAvailableDate} from './utils';\nimport {\n  Calendar,\n  CalendarDate,\n  DateDuration,\n  DateFormatter,\n  endOfMonth,\n  endOfWeek,\n  getDayOfWeek,\n  GregorianCalendar,\n  isSameDay,\n  startOfMonth,\n  startOfWeek,\n  toCalendar,\n  toCalendarDate,\n  today\n} from '@internationalized/date';\nimport {CalendarProps, DateValue} from '@react-types/calendar';\nimport {CalendarState} from './types';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useState} from 'react';\nimport {ValidationState} from '@react-types/shared';\n\nexport interface CalendarStateOptions<T extends DateValue = DateValue> extends CalendarProps<T> {\n  /** The locale to display and edit the value according to. */\n  locale: string,\n  /**\n   * A function that creates a [Calendar](../internationalized/date/Calendar.html)\n   * object for a given calendar identifier. Such a function may be imported from the\n   * `@internationalized/date` package, or manually implemented to include support for\n   * only certain calendars.\n   */\n  createCalendar: (name: string) => Calendar,\n  /**\n   * The amount of days that will be displayed at once. This affects how pagination works.\n   * @default {months: 1}\n   */\n  visibleDuration?: DateDuration,\n  /** Determines how to align the initial selection relative to the visible date range. */\n  selectionAlignment?: 'start' | 'center' | 'end'\n}\n\n/**\n * Provides state management for a calendar component.\n * A calendar displays one or more date grids and allows users to select a single date.\n */\nexport function useCalendarState<T extends DateValue = DateValue>(props: CalendarStateOptions<T>): CalendarState {\n  let defaultFormatter = useMemo(() => new DateFormatter(props.locale), [props.locale]);\n  let resolvedOptions = useMemo(() => defaultFormatter.resolvedOptions(), [defaultFormatter]);\n  let {\n    locale,\n    createCalendar,\n    visibleDuration = {months: 1},\n    minValue,\n    maxValue,\n    selectionAlignment,\n    isDateUnavailable,\n    pageBehavior = 'visible'\n  } = props;\n  let calendar = useMemo(() => createCalendar(resolvedOptions.calendar), [createCalendar, resolvedOptions.calendar]);\n\n  let [value, setControlledValue] = useControlledState<DateValue>(props.value, props.defaultValue, props.onChange);\n  let calendarDateValue = useMemo(() => value ? toCalendar(toCalendarDate(value), calendar) : null, [value, calendar]);\n  let timeZone = useMemo(() => value && 'timeZone' in value ? value.timeZone : resolvedOptions.timeZone, [value, resolvedOptions.timeZone]);\n  let focusedCalendarDate = useMemo(() => (\n    props.focusedValue\n      ? constrainValue(toCalendar(toCalendarDate(props.focusedValue), calendar), minValue, maxValue)\n      : undefined\n  ), [props.focusedValue, calendar, minValue, maxValue]);\n  let defaultFocusedCalendarDate = useMemo(() => (\n    constrainValue(\n      props.defaultFocusedValue\n        ? toCalendar(toCalendarDate(props.defaultFocusedValue), calendar)\n        : calendarDateValue || toCalendar(today(timeZone), calendar),\n      minValue,\n      maxValue\n    )\n  ), [props.defaultFocusedValue, calendarDateValue, timeZone, calendar, minValue, maxValue]);\n  let [focusedDate, setFocusedDate] = useControlledState(focusedCalendarDate, defaultFocusedCalendarDate, props.onFocusChange);\n  let [startDate, setStartDate] = useState(() => {\n    switch (selectionAlignment) {\n      case 'start':\n        return alignStart(focusedDate, visibleDuration, locale, minValue, maxValue);\n      case 'end':\n        return alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue);\n      case 'center':\n      default:\n        return alignCenter(focusedDate, visibleDuration, locale, minValue, maxValue);\n    }\n  });\n  let [isFocused, setFocused] = useState(props.autoFocus || false);\n\n  let endDate = useMemo(() => {\n    let duration = {...visibleDuration};\n    if (duration.days) {\n      duration.days--;\n    } else {\n      duration.days = -1;\n    }\n    return startDate.add(duration);\n  }, [startDate, visibleDuration]);\n\n  // Reset focused date and visible range when calendar changes.\n  let [lastCalendarIdentifier, setLastCalendarIdentifier] = useState(calendar.identifier);\n  if (calendar.identifier !== lastCalendarIdentifier) {\n    let newFocusedDate = toCalendar(focusedDate, calendar);\n    setStartDate(alignCenter(newFocusedDate, visibleDuration, locale, minValue, maxValue));\n    setFocusedDate(newFocusedDate);\n    setLastCalendarIdentifier(calendar.identifier);\n  }\n\n  if (isInvalid(focusedDate, minValue, maxValue)) {\n    // If the focused date was moved to an invalid value, it can't be focused, so constrain it.\n    setFocusedDate(constrainValue(focusedDate, minValue, maxValue));\n  } else if (focusedDate.compare(startDate) < 0) {\n    setStartDate(alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue));\n  } else if (focusedDate.compare(endDate) > 0) {\n    setStartDate(alignStart(focusedDate, visibleDuration, locale, minValue, maxValue));\n  }\n\n  // Sets focus to a specific cell date\n  function focusCell(date: CalendarDate) {\n    date = constrainValue(date, minValue, maxValue);\n    setFocusedDate(date);\n  }\n\n  function setValue(newValue: CalendarDate) {\n    if (!props.isDisabled && !props.isReadOnly) {\n      newValue = constrainValue(newValue, minValue, maxValue);\n      newValue = previousAvailableDate(newValue, startDate, isDateUnavailable);\n      if (!newValue) {\n        return;\n      }\n\n      // The display calendar should not have any effect on the emitted value.\n      // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n      newValue = toCalendar(newValue, value?.calendar || new GregorianCalendar());\n\n      // Preserve time if the input value had one.\n      if (value && 'hour' in value) {\n        setControlledValue(value.set(newValue));\n      } else {\n        setControlledValue(newValue);\n      }\n    }\n  }\n\n  let isUnavailable = useMemo(() => {\n    if (!calendarDateValue) {\n      return false;\n    }\n\n    if (isDateUnavailable && isDateUnavailable(calendarDateValue)) {\n      return true;\n    }\n\n    return isInvalid(calendarDateValue, minValue, maxValue);\n  }, [calendarDateValue, isDateUnavailable, minValue, maxValue]);\n  let isValueInvalid = props.isInvalid || props.validationState === 'invalid' || isUnavailable;\n  let validationState: ValidationState = isValueInvalid ? 'invalid' : null;\n\n  let pageDuration = useMemo(() => {\n    if (pageBehavior === 'visible') {\n      return visibleDuration;\n    }\n\n    return unitDuration(visibleDuration);\n  }, [pageBehavior, visibleDuration]);\n\n  return {\n    isDisabled: props.isDisabled,\n    isReadOnly: props.isReadOnly,\n    value: calendarDateValue,\n    setValue,\n    visibleRange: {\n      start: startDate,\n      end: endDate\n    },\n    minValue,\n    maxValue,\n    focusedDate,\n    timeZone,\n    validationState,\n    isValueInvalid,\n    setFocusedDate(date) {\n      focusCell(date);\n      setFocused(true);\n    },\n    focusNextDay() {\n      focusCell(focusedDate.add({days: 1}));\n    },\n    focusPreviousDay() {\n      focusCell(focusedDate.subtract({days: 1}));\n    },\n    focusNextRow() {\n      if (visibleDuration.days) {\n        this.focusNextPage();\n      } else if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {\n        focusCell(focusedDate.add({weeks: 1}));\n      }\n    },\n    focusPreviousRow() {\n      if (visibleDuration.days) {\n        this.focusPreviousPage();\n      } else if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {\n        focusCell(focusedDate.subtract({weeks: 1}));\n      }\n    },\n    focusNextPage() {\n      let start = startDate.add(pageDuration);\n      setFocusedDate(constrainValue(focusedDate.add(pageDuration), minValue, maxValue));\n      setStartDate(\n        alignStart(\n          constrainStart(focusedDate, start, pageDuration, locale, minValue, maxValue),\n          pageDuration,\n          locale\n        )\n      );\n    },\n    focusPreviousPage() {\n      let start = startDate.subtract(pageDuration);\n      setFocusedDate(constrainValue(focusedDate.subtract(pageDuration), minValue, maxValue));\n      setStartDate(\n        alignStart(\n          constrainStart(focusedDate, start, pageDuration, locale, minValue, maxValue),\n          pageDuration,\n          locale\n        )\n      );\n    },\n    focusSectionStart() {\n      if (visibleDuration.days) {\n        focusCell(startDate);\n      } else if (visibleDuration.weeks) {\n        focusCell(startOfWeek(focusedDate, locale));\n      } else if (visibleDuration.months || visibleDuration.years) {\n        focusCell(startOfMonth(focusedDate));\n      }\n    },\n    focusSectionEnd() {\n      if (visibleDuration.days) {\n        focusCell(endDate);\n      } else if (visibleDuration.weeks) {\n        focusCell(endOfWeek(focusedDate, locale));\n      } else if (visibleDuration.months || visibleDuration.years) {\n        focusCell(endOfMonth(focusedDate));\n      }\n    },\n    focusNextSection(larger) {\n      if (!larger && !visibleDuration.days) {\n        focusCell(focusedDate.add(unitDuration(visibleDuration)));\n        return;\n      }\n\n      if (visibleDuration.days) {\n        this.focusNextPage();\n      } else if (visibleDuration.weeks) {\n        focusCell(focusedDate.add({months: 1}));\n      } else if (visibleDuration.months || visibleDuration.years) {\n        focusCell(focusedDate.add({years: 1}));\n      }\n    },\n    focusPreviousSection(larger) {\n      if (!larger && !visibleDuration.days) {\n        focusCell(focusedDate.subtract(unitDuration(visibleDuration)));\n        return;\n      }\n\n      if (visibleDuration.days) {\n        this.focusPreviousPage();\n      } else if (visibleDuration.weeks) {\n        focusCell(focusedDate.subtract({months: 1}));\n      } else if (visibleDuration.months || visibleDuration.years) {\n        focusCell(focusedDate.subtract({years: 1}));\n      }\n    },\n    selectFocusedDate() {\n      setValue(focusedDate);\n    },\n    selectDate(date) {\n      setValue(date);\n    },\n    isFocused,\n    setFocused,\n    isInvalid(date) {\n      return isInvalid(date, minValue, maxValue);\n    },\n    isSelected(date) {\n      return calendarDateValue != null && isSameDay(date, calendarDateValue) && !this.isCellDisabled(date) && !this.isCellUnavailable(date);\n    },\n    isCellFocused(date) {\n      return isFocused && focusedDate && isSameDay(date, focusedDate);\n    },\n    isCellDisabled(date) {\n      return props.isDisabled || date.compare(startDate) < 0 || date.compare(endDate) > 0 || this.isInvalid(date, minValue, maxValue);\n    },\n    isCellUnavailable(date) {\n      return props.isDateUnavailable && props.isDateUnavailable(date);\n    },\n    isPreviousVisibleRangeInvalid() {\n      let prev = startDate.subtract({days: 1});\n      return isSameDay(prev, startDate) || this.isInvalid(prev, minValue, maxValue);\n    },\n    isNextVisibleRangeInvalid() {\n      // Adding may return the same date if we reached the end of time\n      // according to the calendar system (e.g. 9999-12-31).\n      let next = endDate.add({days: 1});\n      return isSameDay(next, endDate) || this.isInvalid(next, minValue, maxValue);\n    },\n    getDatesInWeek(weekIndex, from = startDate) {\n      // let date = startOfWeek(from, locale);\n      let date = from.add({weeks: weekIndex});\n      let dates = [];\n\n      date = startOfWeek(date, locale);\n\n      // startOfWeek will clamp dates within the calendar system's valid range, which may\n      // start in the middle of a week. In this case, add null placeholders.\n      let dayOfWeek = getDayOfWeek(date, locale);\n      for (let i = 0; i < dayOfWeek; i++) {\n        dates.push(null);\n      }\n\n      while (dates.length < 7) {\n        dates.push(date);\n        let nextDate = date.add({days: 1});\n        if (isSameDay(date, nextDate)) {\n          // If the next day is the same, we have hit the end of the calendar system.\n          break;\n        }\n        date = nextDate;\n      }\n\n      // Add null placeholders if at the end of the calendar system.\n      while (dates.length < 7) {\n        dates.push(null);\n      }\n\n      return dates;\n    }\n  };\n}\n\nfunction unitDuration(duration: DateDuration) {\n  let unit = {...duration};\n  for (let key in duration) {\n    unit[key] = 1;\n  }\n  return unit;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n  CalendarDate,\n  DateDuration,\n  maxDate,\n  minDate,\n  startOfMonth,\n  startOfWeek,\n  startOfYear,\n  toCalendarDate\n} from '@internationalized/date';\nimport {DateValue} from '@react-types/calendar';\n\nexport function isInvalid(date: DateValue, minValue: DateValue, maxValue: DateValue) {\n  return (minValue != null && date.compare(minValue) < 0) ||\n    (maxValue != null && date.compare(maxValue) > 0);\n}\n\nexport function alignCenter(date: CalendarDate, duration: DateDuration, locale: string, minValue?: DateValue, maxValue?: DateValue) {\n  let halfDuration: DateDuration = {};\n  for (let key in duration) {\n    halfDuration[key] = Math.floor(duration[key] / 2);\n    if (halfDuration[key] > 0 && duration[key] % 2 === 0) {\n      halfDuration[key]--;\n    }\n  }\n\n  let aligned = alignStart(date, duration, locale).subtract(halfDuration);\n  return constrainStart(date, aligned, duration, locale, minValue, maxValue);\n}\n\nexport function alignStart(date: CalendarDate, duration: DateDuration, locale: string, minValue?: DateValue, maxValue?: DateValue) {\n  // align to the start of the largest unit\n  let aligned = date;\n  if (duration.years) {\n    aligned = startOfYear(date);\n  } else if (duration.months) {\n    aligned = startOfMonth(date);\n  } else if (duration.weeks) {\n    aligned = startOfWeek(date, locale);\n  }\n\n  return constrainStart(date, aligned, duration, locale, minValue, maxValue);\n}\n\nexport function alignEnd(date: CalendarDate, duration: DateDuration, locale: string, minValue?: DateValue, maxValue?: DateValue) {\n  let d = {...duration};\n  // subtract 1 from the smallest unit\n  if (duration.days) {\n    d.days--;\n  } else if (duration.weeks) {\n    d.weeks--;\n  } else if (duration.months) {\n    d.months--;\n  } else if (duration.years) {\n    d.years--;\n  }\n\n  let aligned = alignStart(date, duration, locale).subtract(d);\n  return constrainStart(date, aligned, duration, locale, minValue, maxValue);\n}\n\nexport function constrainStart(\n  date: CalendarDate,\n  aligned: CalendarDate,\n  duration: DateDuration,\n  locale: string,\n  minValue: DateValue,\n  maxValue: DateValue) {\n  if (minValue && date.compare(minValue) >= 0) {\n    aligned = maxDate(\n      aligned,\n      alignStart(toCalendarDate(minValue), duration, locale)\n    );\n  }\n\n  if (maxValue && date.compare(maxValue) <= 0) {\n    aligned = minDate(\n      aligned,\n      alignEnd(toCalendarDate(maxValue), duration, locale)\n    );\n  }\n\n  return aligned;\n}\n\nexport function constrainValue(date: CalendarDate, minValue: DateValue, maxValue: DateValue) {\n  if (minValue) {\n    date = maxDate(date, toCalendarDate(minValue));\n  }\n\n  if (maxValue) {\n    date = minDate(date, toCalendarDate(maxValue));\n  }\n\n  return date;\n}\n\nexport function previousAvailableDate(date: CalendarDate, minValue: DateValue, isDateUnavailable: (date: CalendarDate) => boolean) {\n  if (!isDateUnavailable) {\n    return date;\n  }\n\n  while (date.compare(minValue) >= 0 && isDateUnavailable(date)) {\n    date = date.subtract({days: 1});\n  }\n\n  if (date.compare(minValue) >= 0) {\n    return date;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {alignCenter, constrainValue, isInvalid, previousAvailableDate} from './utils';\nimport {Calendar, CalendarDate, DateDuration, GregorianCalendar, isEqualDay, maxDate, minDate, toCalendar, toCalendarDate} from '@internationalized/date';\nimport {CalendarState, RangeCalendarState} from './types';\nimport {DateRange, DateValue, RangeCalendarProps} from '@react-types/calendar';\nimport {RangeValue, ValidationState} from '@react-types/shared';\nimport {useCalendarState} from './useCalendarState';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useRef, useState} from 'react';\n\nexport interface RangeCalendarStateOptions<T extends DateValue = DateValue> extends RangeCalendarProps<T> {\n  /** The locale to display and edit the value according to. */\n  locale: string,\n  /**\n   * A function that creates a [Calendar](../internationalized/date/Calendar.html)\n   * object for a given calendar identifier. Such a function may be imported from the\n   * `@internationalized/date` package, or manually implemented to include support for\n   * only certain calendars.\n   */\n  createCalendar: (name: string) => Calendar,\n  /**\n   * The amount of days that will be displayed at once. This affects how pagination works.\n   * @default {months: 1}\n   */\n  visibleDuration?: DateDuration\n}\n\n/**\n * Provides state management for a range calendar component.\n * A range calendar displays one or more date grids and allows users to select a contiguous range of dates.\n */\nexport function useRangeCalendarState<T extends DateValue = DateValue>(props: RangeCalendarStateOptions<T>): RangeCalendarState {\n  let {value: valueProp, defaultValue, onChange, createCalendar, locale, visibleDuration = {months: 1}, minValue, maxValue, ...calendarProps} = props;\n  let [value, setValue] = useControlledState<DateRange>(\n    valueProp,\n    defaultValue || null,\n    onChange\n  );\n\n  let [anchorDate, setAnchorDateState] = useState(null);\n  let alignment: 'center' | 'start' = 'center';\n  if (value && value.start && value.end) {\n    let start = alignCenter(toCalendarDate(value.start), visibleDuration, locale, minValue, maxValue);\n    let end = start.add(visibleDuration).subtract({days: 1});\n\n    if (value.end.compare(end) > 0) {\n      alignment = 'start';\n    }\n  }\n\n  // Available range must be stored in a ref so we have access to the updated version immediately in `isInvalid`.\n  let availableRangeRef = useRef<RangeValue<DateValue>>(null);\n  let [availableRange, setAvailableRange] = useState<RangeValue<DateValue>>(null);\n  let min = useMemo(() => maxDate(minValue, availableRange?.start), [minValue, availableRange]);\n  let max = useMemo(() => minDate(maxValue, availableRange?.end), [maxValue, availableRange]);\n\n  let calendar = useCalendarState({\n    ...calendarProps,\n    value: value && value.start,\n    createCalendar,\n    locale,\n    visibleDuration,\n    minValue: min,\n    maxValue: max,\n    selectionAlignment: alignment\n  });\n\n  let updateAvailableRange = (date) => {\n    if (date && props.isDateUnavailable && !props.allowsNonContiguousRanges) {\n      availableRangeRef.current = {\n        start: nextUnavailableDate(date, calendar, -1),\n        end: nextUnavailableDate(date, calendar, 1)\n      };\n      setAvailableRange(availableRangeRef.current);\n    } else {\n      availableRangeRef.current = null;\n      setAvailableRange(null);\n    }\n  };\n\n  // If the visible range changes, we need to update the available range.\n  let [lastVisibleRange, setLastVisibleRange] = useState(calendar.visibleRange);\n  if (!isEqualDay(calendar.visibleRange.start, lastVisibleRange.start) || !isEqualDay(calendar.visibleRange.end, lastVisibleRange.end)) {\n    updateAvailableRange(anchorDate);\n    setLastVisibleRange(calendar.visibleRange);\n  }\n\n  let setAnchorDate = (date: CalendarDate) => {\n    if (date) {\n      setAnchorDateState(date);\n      updateAvailableRange(date);\n    } else {\n      setAnchorDateState(null);\n      updateAvailableRange(null);\n    }\n  };\n\n  let highlightedRange = anchorDate ? makeRange(anchorDate, calendar.focusedDate) : value && makeRange(value.start, value.end);\n  let selectDate = (date: CalendarDate) => {\n    if (props.isReadOnly) {\n      return;\n    }\n\n    date = constrainValue(date, min, max);\n    date = previousAvailableDate(date, calendar.visibleRange.start, props.isDateUnavailable);\n    if (!date) {\n      return;\n    }\n\n    if (!anchorDate) {\n      setAnchorDate(date);\n    } else {\n      let range = makeRange(anchorDate, date);\n      setValue({\n        start: convertValue(range.start, value?.start),\n        end: convertValue(range.end, value?.end)\n      });\n      setAnchorDate(null);\n    }\n  };\n\n  let [isDragging, setDragging] = useState(false);\n\n  let {isDateUnavailable} = props;\n  let isInvalidSelection = useMemo(() => {\n    if (!value || anchorDate) {\n      return false;\n    }\n\n    if (isDateUnavailable && (isDateUnavailable(value.start) || isDateUnavailable(value.end))) {\n      return true;\n    }\n\n    return isInvalid(value.start, minValue, maxValue) || isInvalid(value.end, minValue, maxValue);\n  }, [isDateUnavailable, value, anchorDate, minValue, maxValue]);\n\n  let isValueInvalid = props.isInvalid || props.validationState === 'invalid' || isInvalidSelection;\n  let validationState: ValidationState = isValueInvalid ? 'invalid' : null;\n\n  return {\n    ...calendar,\n    value,\n    setValue,\n    anchorDate,\n    setAnchorDate,\n    highlightedRange,\n    validationState,\n    isValueInvalid,\n    selectFocusedDate() {\n      selectDate(calendar.focusedDate);\n    },\n    selectDate,\n    highlightDate(date) {\n      if (anchorDate) {\n        calendar.setFocusedDate(date);\n      }\n    },\n    isSelected(date) {\n      return highlightedRange && date.compare(highlightedRange.start) >= 0 && date.compare(highlightedRange.end) <= 0 && !calendar.isCellDisabled(date) && !calendar.isCellUnavailable(date);\n    },\n    isInvalid(date) {\n      return calendar.isInvalid(date) || isInvalid(date, availableRangeRef.current?.start, availableRangeRef.current?.end);\n    },\n    isDragging,\n    setDragging\n  };\n}\n\nfunction makeRange(start: DateValue, end: DateValue): RangeValue<CalendarDate> {\n  if (!start || !end) {\n    return null;\n  }\n\n  if (end.compare(start) < 0) {\n    [start, end] = [end, start];\n  }\n\n  return {start: toCalendarDate(start), end: toCalendarDate(end)};\n}\n\nfunction convertValue(newValue: CalendarDate, oldValue: DateValue) {\n  // The display calendar should not have any effect on the emitted value.\n  // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n  newValue = toCalendar(newValue, oldValue?.calendar || new GregorianCalendar());\n\n  // Preserve time if the input value had one.\n  if (oldValue && 'hour' in oldValue) {\n    return oldValue.set(newValue);\n  }\n\n  return newValue;\n}\n\nfunction nextUnavailableDate(anchorDate: CalendarDate, state: CalendarState, dir: number) {\n  let nextDate = anchorDate.add({days: dir});\n  while (\n    (dir < 0 ? nextDate.compare(state.visibleRange.start) >= 0 : nextDate.compare(state.visibleRange.end) <= 0) &&\n    !state.isCellUnavailable(nextDate)\n  ) {\n    nextDate = nextDate.add({days: dir});\n  }\n\n  if (state.isCellUnavailable(nextDate)) {\n    return nextDate.add({days: -dir});\n  }\n\n  return null;\n}\n"],"names":[],"version":3,"file":"main.js.map"}