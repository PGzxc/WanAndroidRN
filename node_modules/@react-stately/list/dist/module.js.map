{"mappings":"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","sources":["packages/@react-stately/list/src/index.ts","packages/@react-stately/list/src/useListState.ts","packages/@react-stately/list/src/ListCollection.ts","packages/@react-stately/list/src/useSingleSelectListState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {ListProps, ListState} from './useListState';\nexport type {SingleSelectListProps, SingleSelectListState} from './useSingleSelectListState';\nexport {useListState} from './useListState';\nexport {useSingleSelectListState} from './useSingleSelectListState';\nexport {ListCollection} from './ListCollection';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, CollectionStateBase, Node} from '@react-types/shared';\nimport {Key, useCallback, useEffect, useMemo, useRef} from 'react';\nimport {ListCollection} from './ListCollection';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\nimport {useCollection} from '@react-stately/collections';\n\nexport interface ListProps<T> extends CollectionStateBase<T>, MultipleSelectionStateProps {\n  /** Filter function to generate a filtered list of nodes. */\n  filter?: (nodes: Iterable<Node<T>>) => Iterable<Node<T>>,\n  /** @private */\n  suppressTextValueWarning?: boolean\n}\n\nexport interface ListState<T> {\n  /** A collection of items in the list. */\n  collection: Collection<Node<T>>,\n\n  /** A set of items that are disabled. */\n  disabledKeys: Set<Key>,\n\n  /** A selection manager to read and update multiple selection state. */\n  selectionManager: SelectionManager\n}\n\n/**\n * Provides state management for list-like components. Handles building a collection\n * of items from props, and manages multiple selection state.\n */\nexport function useListState<T extends object>(props: ListProps<T>): ListState<T>  {\n  let {filter} = props;\n\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n\n  let factory = useCallback(nodes => filter ? new ListCollection(filter(nodes)) : new ListCollection(nodes as Iterable<Node<T>>), [filter]);\n  let context = useMemo(() => ({suppressTextValueWarning: props.suppressTextValueWarning}), [props.suppressTextValueWarning]);\n\n  let collection = useCollection(props, factory, context);\n\n  let selectionManager = useMemo(() =>\n    new SelectionManager(collection, selectionState)\n    , [collection, selectionState]\n  );\n\n  // Reset focused key if that item is deleted from the collection.\n  const cachedCollection = useRef(null);\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const startItem = cachedCollection.current.getItem(selectionState.focusedKey);\n      const cachedItemNodes = [...cachedCollection.current.getKeys()].map(\n        key => {\n          const itemNode = cachedCollection.current.getItem(key);\n          return itemNode.type === 'item' ? itemNode : null;\n        }\n      ).filter(node => node !== null);\n      const itemNodes = [...collection.getKeys()].map(\n        key => {\n          const itemNode = collection.getItem(key);\n          return itemNode.type === 'item' ? itemNode : null;\n        }\n      ).filter(node => node !== null);\n      const diff = cachedItemNodes.length - itemNodes.length;\n      let index = Math.min(\n        (\n          diff > 1 ?\n          Math.max(startItem.index - diff + 1, 0) :\n          startItem.index\n        ),\n        itemNodes.length - 1);\n      let newNode:Node<T>;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(itemNodes[index].key)) {\n          newNode = itemNodes[index];\n          break;\n        }\n        // Find next, not disabled item.\n        if (index < itemNodes.length - 1) {\n          index++;\n        // Otherwise, find previous, not disabled item.\n        } else {\n          if (index > startItem.index) {\n            index = startItem.index;\n          }\n          index--;\n        }\n      }\n      selectionState.setFocusedKey(newNode ? newNode.key : null);\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Node} from '@react-types/shared';\nimport {Key} from 'react';\n\nexport class ListCollection<T> implements Collection<Node<T>> {\n  private keyMap: Map<Key, Node<T>> = new Map();\n  private iterable: Iterable<Node<T>>;\n  private firstKey: Key;\n  private lastKey: Key;\n\n  constructor(nodes: Iterable<Node<T>>) {\n    this.iterable = nodes;\n\n    let visit = (node: Node<T>) => {\n      this.keyMap.set(node.key, node);\n\n      if (node.childNodes && node.type === 'section') {\n        for (let child of node.childNodes) {\n          visit(child);\n        }\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let last: Node<T>;\n    let index = 0;\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n\n      if (node.type === 'item') {\n        node.index = index++;\n      }\n\n      last = node;\n\n      // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n      last.nextKey = undefined;\n    }\n\n    this.lastKey = last?.key;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    return this.lastKey;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  getChildren(key: Key): Iterable<Node<T>> {\n    let node = this.keyMap.get(key);\n    return node?.childNodes || [];\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionStateBase, Node, SingleSelection} from '@react-types/shared';\nimport {Key, useMemo} from 'react';\nimport {ListState, useListState} from './useListState';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface SingleSelectListProps<T> extends CollectionStateBase<T>, Omit<SingleSelection, 'disallowEmptySelection'> {\n  /** Filter function to generate a filtered list of nodes. */\n  filter?: (nodes: Iterable<Node<T>>) => Iterable<Node<T>>,\n  /** @private */\n  suppressTextValueWarning?: boolean\n}\n\nexport interface SingleSelectListState<T> extends ListState<T> {\n  /** The key for the currently selected item. */\n  readonly selectedKey: Key,\n\n  /** Sets the selected key. */\n  setSelectedKey(key: Key | null): void,\n\n  /** The value of the currently selected item. */\n  readonly selectedItem: Node<T>\n}\n\n/**\n * Provides state management for list-like components with single selection.\n * Handles building a collection of items from props, and manages selection state.\n */\nexport function useSingleSelectListState<T extends object>(props: SingleSelectListProps<T>): SingleSelectListState<T>  {\n  let [selectedKey, setSelectedKey] = useControlledState(props.selectedKey, props.defaultSelectedKey ?? null, props.onSelectionChange);\n  let selectedKeys = useMemo(() => selectedKey != null ? [selectedKey] : [], [selectedKey]);\n  let {collection, disabledKeys, selectionManager} = useListState({\n    ...props,\n    selectionMode: 'single',\n    disallowEmptySelection: true,\n    allowDuplicateSelectionEvents: true,\n    selectedKeys,\n    onSelectionChange: (keys: Set<Key>) => {\n      let key = keys.values().next().value ?? null;\n\n      // Always fire onSelectionChange, even if the key is the same\n      // as the current key (useControlledState does not).\n      if (key === selectedKey && props.onSelectionChange) {\n        props.onSelectionChange(key);\n      }\n\n      setSelectedKey(key);\n    }\n  });\n\n  let selectedItem = selectedKey != null\n    ? collection.getItem(selectedKey)\n    : null;\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager,\n    selectedKey,\n    setSelectedKey,\n    selectedItem\n  };\n}\n"],"names":[],"version":3,"file":"module.js.map"}