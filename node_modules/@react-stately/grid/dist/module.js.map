{"mappings":"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","sources":["packages/@react-stately/grid/src/index.ts","packages/@react-stately/grid/src/useGridState.ts","packages/@react-stately/grid/src/GridCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useGridState} from './useGridState';\nexport {GridCollection} from './GridCollection';\n\nexport type {GridStateOptions, GridState} from './useGridState';\n","import {getChildNodes, getFirstItem, getLastItem} from '@react-stately/collections';\nimport {GridCollection, GridNode} from '@react-types/grid';\nimport {Key, useEffect, useMemo, useRef} from 'react';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\n\nexport interface GridState<T, C extends GridCollection<T>> {\n  collection: C,\n  /** A set of keys for rows that are disabled. */\n  disabledKeys: Set<Key>,\n  /** A selection manager to read and update row selection state. */\n  selectionManager: SelectionManager,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean\n}\n\nexport interface GridStateOptions<T, C extends GridCollection<T>> extends MultipleSelectionStateProps {\n  collection: C,\n  disabledKeys?: Iterable<Key>,\n  focusMode?: 'row' | 'cell'\n}\n\n/**\n * Provides state management for a grid component. Handles row selection and focusing a grid cell's focusable child if applicable.\n */\nexport function useGridState<T extends object, C extends GridCollection<T>>(props: GridStateOptions<T, C>): GridState<T, C> {\n  let {collection, focusMode} = props;\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n      props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n    , [props.disabledKeys]);\n\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n      if (item?.type === 'item') {\n        let children = getChildNodes(item, collection);\n        if (child === 'last') {\n          key = getLastItem(children)?.key;\n        } else {\n          key = getFirstItem(children)?.key;\n        }\n      }\n    }\n\n    setFocusedKey(key, child);\n  };\n\n  let selectionManager = useMemo(() =>\n    new SelectionManager(collection, selectionState)\n    , [collection, selectionState]\n  );\n\n  // Reset focused key if that item is deleted from the collection.\n  const cachedCollection = useRef(null);\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const node = cachedCollection.current.getItem(selectionState.focusedKey);\n      const parentNode =\n        node.parentKey != null && (node.type === 'cell' || node.type === 'rowheader' || node.type === 'column') ?\n        cachedCollection.current.getItem(node.parentKey) :\n        node;\n      const cachedRows = cachedCollection.current.rows;\n      const rows = collection.rows;\n      const diff = cachedRows.length - rows.length;\n      let index = Math.min(\n        (\n          diff > 1 ?\n          Math.max(parentNode.index - diff + 1, 0) :\n          parentNode.index\n        ),\n        rows.length - 1);\n      let newRow:GridNode<T>;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== 'headerrow') {\n          newRow = rows[index];\n          break;\n        }\n        // Find next, not disabled row.\n        if (index < rows.length - 1) {\n          index++;\n        // Otherwise, find previous, not disabled row.\n        } else {\n          if (index > parentNode.index) {\n            index = parentNode.index;\n          }\n          index--;\n        }\n      }\n      if (newRow) {\n        const childNodes = newRow.hasChildNodes ? [...getChildNodes(newRow, collection)] : [];\n        const keyToFocus =\n          newRow.hasChildNodes &&\n          parentNode !== node &&\n          node.index < childNodes.length ?\n          childNodes[node.index].key :\n          newRow.key;\n        selectionState.setFocusedKey(keyToFocus);\n      } else {\n        selectionState.setFocusedKey(null);\n      }\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n\n  return {\n    collection,\n    disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {GridNode, GridRow, GridCollection as IGridCollection} from '@react-types/grid';\nimport {Key} from 'react';\n\n\ninterface GridCollectionOptions<T> {\n  columnCount: number,\n  items: GridRow<T>[],\n  visitNode?: (cell: GridNode<T>) => GridNode<T>\n}\n\nexport class GridCollection<T> implements IGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>> = new Map();\n  columnCount: number;\n  rows: GridNode<T>[];\n\n  constructor(opts?: GridCollectionOptions<T>) {\n    this.keyMap = new Map();\n    this.columnCount = opts?.columnCount;\n    this.rows = [];\n\n    let visit = (node: GridNode<T>) => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) {\n        node = opts.visitNode(node);\n      }\n\n      this.keyMap.set(node.key, node);\n\n      let childKeys = new Set();\n      let last: GridNode<T>;\n      for (let child of node.childNodes) {\n        if (child.type === 'cell' && child.parentKey == null) {\n          // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n        childKeys.add(child.key);\n\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        visit(child);\n        last = child;\n      }\n\n      if (last) {\n        last.nextKey = null;\n      }\n\n      // Remove deleted nodes and their children from the key map\n      if (prevNode) {\n        for (let child of prevNode.childNodes) {\n          if (!childKeys.has(child.key)) {\n            remove(child);\n          }\n        }\n      }\n    };\n\n    let remove = (node: GridNode<T>) => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) {\n        if (this.keyMap.get(child.key) === child) {\n          remove(child);\n        }\n      }\n    };\n\n    let last: GridNode<T>;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: 'row-' + i,\n        type: 'row',\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node\n      } as GridNode<T>;\n\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else {\n        rowNode.prevKey = null;\n      }\n\n      this.rows.push(rowNode);\n      visit(rowNode);\n\n      last = rowNode;\n    });\n\n    if (last) {\n      last.nextKey = null;\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* [...this.rows];\n  }\n\n  get size() {\n    return [...this.rows].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return [...this.rows][0]?.key;\n  }\n\n  getLastKey() {\n    let rows = [...this.rows];\n    return rows[rows.length - 1]?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  getChildren(key: Key): Iterable<GridNode<T>> {\n    let node = this.keyMap.get(key);\n    return node?.childNodes || [];\n  }\n}\n"],"names":[],"version":3,"file":"module.js.map"}